<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>戰鬥</title>
    <link rel="stylesheet" href="style.css">
    <style>
        body {
        }

        .item {
            margin: 10px 0;
        }

        /* 選中的敵人 */
        .selected {
            box-shadow: 0 0 5px rgba(255, 55, 55, 0.4); /* 光暈 */
            border: 2px solid rgba(255, 55, 55, 1); /* 紅框 */
            background-color: rgba(0,0,0,0.5);
            color: #fff;
        }

        /* 可行動成員 */
        .availableMembers {
            border: 1px solid rgba(255, 255, 255, 1); /* 白框 */
            color: #fff;
        }

        /* HP 受到攻擊後變成紅字 */
        .red-hp {
            color: red;
            font-weight: bold;
        }

        /* 狀態圖示按鈕 */
        .status-button {
            font-size: 0.7em;
            margin: 0;
            padding: 0;
            background: none;
        }

        /* 戰鬥訊息 */
        .battle-text {
            font-size: 0.9em;
            color: #999;
        }



    </style>
</head>
<body>
    <!-- 按鈕列 -->
    <div id="buttonBar"></div>

    <!-- 通知框 -->
    <div id="toast-container"></div>

    <!-- 主要內容區域 -->
    <div id="main" class="main-content">
        <h3 id="situation" class="center"></h3>

        <div id="battle-content">
            <!-- 敵人列表 -->
            <div class="item bottomborder center small">➵ 敵方</div>
            <p class="note small center" id="enemy-note"></p>
            <div id="enemy-infor"></div>
            <div id="enemy-container" style="display: flex"></div>

            <br>

            <!-- 我方列表 -->
            <div class="item bottomborder center small">我方 ➵</div>
            <p class="note small center" id="team-note"></p>
            <div id="frontMembers-container" style="display: flex"></div>
            <div id="member-container" style="display: flex"></div>
            <div id="member-infor"></div>

            <p id="soul-count"></p>


            <!-- 隊伍按鈕 -->
            <p id="team-action" class="center"></p>
            <div class="menu">
                <div class="row-buttons item background" id="team-btn">
                    <button onclick="selectAttacker('team', 'attack')">⚔️ <span class="small">聯手攻擊</span></button>
                    <button onclick="escape('team')">🏃 <span class="small">一起逃跑</span></button>
                </div>
                <button onclick="endRound()">結束回合</button>
            </div>
        </div>
    </div>

    <!-- 對話區域 -->
    <div id="dialogue" class="main-content"></div>

    <script src="script.js"></script>
    <script>

        // 顯示文本
        const texts = {
            noTarget: "請選擇一個敵人為目標",
            noAttacker: "請選擇我方角色的行動",
            fightWin: (name, damage) => `擊中${name}(${damage})！`,
            fightWinWithStatus: (name, damage, status) => `擊中${name}(${damage})，使他${status}了！`,
            fightLose: (name) => `試圖攻擊${name}，但被躲開了`,
            fightFlyingEnemy: (name) => `${name}飛得太高，無法擊中`,
            killEnemy: (name, damage) => `打敗了${name}(${damage})！`,
            die: (deadMembers) => `${deadMembers}倒下了！`,
            teamFightWin: (name, damage) => `你們聯手，對${name}造成了重創！(${damage})`,
            teamFightLose: (name) => `${name}非常頑強，避開了所有的攻擊`,
            teamKillEnemy: (name, damage) => `你們聯手打敗${name}(${damage})！`,
            escapeSuccess: "順利逃走了",
            escapeFail: "逃跑時被敵人阻擋了！",
            teamEscapeSuccess: (name) => `${name}逃走了`,
            teamEscapeFail: (name) => `${name}跑不過敵人，你們只好停下來！`,
            enemyWin: (name, damage) => `擊中${name}(${damage})！`,
            enemyWinWithStatus: (name, damage, status) => `擊中${name}(${damage})，使他${status}了！`,
            enemyLose: (name) => `試圖攻擊${name}，但被躲開了`,
            enemyKill: (name, damage) => `打敗了${name}(${damage})！`,
            enemyFly: "飛上了高空",
            safe: "順利前進",
            battle: "敵人出現了！",
            surprise: "遭到偷襲了！",
            cannotTalk: "敵人無法理解你說的話。",
            escapePrisoner: (name) => `${name}趁你在對付敵人時逃走了！`,
            demonAttacked: "燃燒了起來",
            bleeding: "流血了",
            prone: "從地上起身",
            petrified: "變成石頭，無法動彈",
            //trap: "觸發陷阱！",
            //enemyComing: "敵人正在趕來的路上，最好快點離開",
        };

        // 畫面載入時
        window.onload = function() {
            getSituation(); // 讀取並執行遇敵方式
            turnSwitch("inBattle"); // 標記為戰鬥中

            preferences(); // 偏好設定
            showButtonBar(); // 顯示按鈕列
            loadBackground(); // 讀取背景
        };

        // 對話資料庫
        const dialogueData = {
            "雷納德": {
                "雷納德幫忙": {
                    npc: "npc",
                    text: "沒事吧？你需要幫忙嗎？",
                    choices: [
                        { text: "拜託了", next: "", action: "(helperJoin(), removeDialogue(), getSituation())" },
                        { text: "不用幫忙", next: "", action: "(removeDialogue(), getSituation())" },
                    ]
                },
            },
        }

    // === 初始化區 ===

        let enemy = {}; // 當前敵人
        let escapeMember= []; // 逃跑成員

        // 讀取並執行遇敵方式
        function getSituation() {
            let situation = parseInt(localStorage.getItem("situation"));
            //situation = 3; // 測試用

            let enemies = JSON.parse(localStorage.getItem("enemies")) || [];

            if (situation === 2 || situation === 5 || situation === 7) {
                // 顯示敵人準備戰鬥的描述
                enemies.forEach(enemy => {
                    localStorage.setItem(`${enemy.id}-action-text`, enemy.actionBattle);
                });

                document.getElementById("situation").textContent = texts.battle; // 顯示遇敵的訊息
                localStorage.removeItem("situation"); // 清除遇敵方式
                console.log("一般遇敵（我方先攻）");

            } else if (situation === 3) {
                document.getElementById("situation").textContent = texts.surprise; // 顯示被偷襲的訊
                localStorage.removeItem("situation"); // 清除遇敵方式
                console.log("被偷襲（敵人先攻）");

                startBattle() // 開始戰鬥
                enemyFight(); // 敵人攻擊

            } else if (situation === 4) {
                // 顯示敵人沒有防備的描述
                enemies.forEach(enemy => {
                    localStorage.setItem(`${enemy.id}-action-text`, enemy.action);
                });
                console.log("發現無防備的敵人（我方第一回合攻擊、逃跑100%成功）");
            }
            startBattle() // 開始戰鬥
        }

        // 開始戰鬥
        function startBattle() {
            loadPartyData(); // 讀取隊伍資料
            endAction(); // 每次載入時跑一次，以防有東西還原
        }

        // 顯示戰鬥圖像
        function generateAvatar() {
            const presentMembers = JSON.parse(localStorage.getItem("presentMembers")) || [];
            const frontMembers = JSON.parse(localStorage.getItem("frontMembers")) || [];
            const availableMembers = JSON.parse(localStorage.getItem("availableMembers")) || [];
            const enemies = JSON.parse(localStorage.getItem("enemies")) || [];

            // 顯示提示
            document.getElementById("team-note").textContent = texts.noAttacker;

            // 創建敵人的圖像
            const enemyMenu = document.getElementById("enemy-container");
            enemyMenu.innerHTML = "";  // 清空選單內容

            enemies.forEach(enemy => {
                const characterDiv = document.createElement("div");
                characterDiv.style.margin = "auto";
                characterDiv.innerHTML = `
                    <button id="${enemy.id}-avatar" class="avatar background">
                        <span class="small note">${enemy.adj}<br>${enemy.name}</span>
                    </button>
                    <div class="center small">
                        <h4 class="hp"><span id="${enemy.id}-HP">${enemy.HP}</span> / ${enemy.MaxHP}</h4>
                    </div>
                `;

                // 按下時
                characterDiv.addEventListener("click", () => {
                    document.getElementById("enemy-infor").innerHTML = ""; // 先清空欄位
                    showEnemy(enemy); // 顯示欄位
                });

                enemyMenu.appendChild(characterDiv);
            });

            // 創建隊員的圖像
            const memberMenu = document.getElementById("member-container");
            memberMenu.innerHTML = "";  // 清空選單內容
            const frontMenu = document.getElementById("frontMembers-container");
            frontMenu.innerHTML = "";  // 清空選單內容

            presentMembers.forEach(member => {
                const characterDiv = document.createElement("div");
                characterDiv.style.margin = "auto";
                characterDiv.innerHTML = `
                    <button id="${member.id}-avatar" class="avatar background">
                        <span class="small note">${member.name}</span>
                    </button>
                    <div class="center small">
                        <h4 class="hp"><span id="${member.id}-HP">${member.HP}</span> / ${member.MaxHP}</h4>
                    </div>
                `;

                // 按下
                characterDiv.addEventListener("click", () => {
                    selectedUser = null // 取消攻擊者
                    document.getElementById("member-infor").innerHTML = ""; // 清空欄位
                    document.getElementById("enemy-infor").innerHTML = ""; // 清空欄位
                    showMember(member); // 顯示欄位
                });

                // 檢查是不是前排成員
                const isFront = frontMembers.some(m => m.id === member.id);
                if (isFront) {
                    frontMenu.appendChild(characterDiv);
                } else {
                    memberMenu.appendChild(characterDiv);
                }
            });

            // 為可行動成員加上標記
            availableMembers.forEach(member => {
                document.getElementById(`${member.id}-avatar`).classList.add("availableMembers");
            });

            // 檢查是否顯示提示
            if (availableMembers.length < 1) {
                document.getElementById("team-note").textContent = ""; // 清除提示
            }

            // 檢查是否顯示隊伍按鈕
            if (availableMembers.length <  2) {
                // 如果可行動的隊員不到 2 個，隱藏隊伍按鈕
                document.getElementById("team-btn").style.display = "none";
            } else {
                // 否則顯示
                document.getElementById("team-btn").style.display = "flex";
            }

            // 如果物品中有可用的紅寶石，就顯示已獻祭的數量
                const playerItems = JSON.parse(localStorage.getItem("playerItems")) || [];
                const ruby = playerItems.find(i => i === "specialItem14");
                if (ruby) {
                    const soulCount = parseInt(localStorage.getItem("soulCount"));
                    document.getElementById('soul-count').textContent = "💀 " + soulCount;
                }
            
            // HP改為紅字
            const redHP = JSON.parse(localStorage.getItem("redHP")) || [];
            redHP.forEach(HP => {
                if (document.getElementById(HP)) {
                    document.getElementById(HP).classList.add("red-hp");
                }
            });

            // 顯示彈跳動畫
            const jumpers = JSON.parse(localStorage.getItem("jumpers")) || [];
            let delay = 0;  // 延遲時間，確保動畫依次進行
            jumpers.forEach(jumper => {
                setTimeout(function() {
                    document.getElementById(jumper).classList.add("jump"); // 顯示彈跳動畫
                }, delay);
                setTimeout(function() {
                    document.getElementById(jumper).classList.remove("jump"); // 移除彈跳動畫
                }, delay + 150);
            })
            localStorage.removeItem("jumpers");

            console.log("敵人:", enemies);
            console.log("可行動的成員", availableMembers);
        }

        // 顯示我方欄位
        function showMember(member) {
            availableMembers = JSON.parse(localStorage.getItem("availableMembers")) || [];
            frontMembers = JSON.parse(localStorage.getItem("frontMembers")) || [];

            const menu = document.getElementById("member-infor");
            menu.innerHTML = "";  // 清空選單內容

            // 創建成員的資料
                const isAvailable = availableMembers.some(m => m.id === member.id);
                const isPlayer = member.id === "player";
                const isFront = frontMembers.some(m => m.id === member.id);

                // 取得武器 emoji
                let weaponIcon = "✊"; // 預設空手
                if (member.weapon && member.weapon.id) {
                    weaponIcon = Array.from(member.weapon.name)[0];  // 取第一個字符（emoji）
                }

                const characterDiv = document.createElement("div");
                characterDiv.innerHTML = `
                    <div id="${member.id}" class="item background">
                        <div class="column-container">
                            <div class="column">
                                <h4>${weaponIcon} ${member.name}</h4>
                            </div>
                            <div class="column right">
                                <h4 class="hp">${member.HP} / ${member.MaxHP}</h4>
                            </div>
                            <button id="${member.id}-close-btn" class="small-button" style="background: none;">×</button>
                        </div>

                        <p id="${member.id}-status"></p>
                        <p id="${member.id}-action" class="battle-text"></p>

                        ${isAvailable ? `
                            <div class="row-buttons ${member.id}-btn">
                                ${isPlayer ? `
                                    <button onclick="selectAttacker('player', 'talk')">💬<br><span class="small">交談</span></button>
                                ` : "" }
                                <button onclick="selectAttacker('${member.id}', 'attack')">⚔️<br><span class="small">攻擊</span></button>
                                <button onclick="useItem('${member.id}')">💰<br><span class="small">物品</span></button>
                                ${isFront ? `
                                    <button onclick="move('${member.id}')">👣<br><span class="small">後退</span></button>
                                ` : `
                                    <button onclick="move('${member.id}')">👣<br><span class="small">前進</span></button>
                                ` }
                                <button onclick="escape('${member.id}')">🏃<br><span class="small">逃跑</span></button>
                            </div>
                        ` : "" }
                    </div>
                `;
                menu.appendChild(characterDiv);

                // 顯示訊息
                const message = localStorage.getItem(`${member.id}-action-text`) || "";
                document.getElementById(`${member.id}-action`).textContent = message;

                // 取得狀態圖示
                const statusList = document.getElementById(`${member.id}-status`);
                statusList.innerHTML = "";  // 清空選單內容
                member.status.forEach(status => {
                    // 生成說明文字
                    const infor = `【${status.name}】${status.description}（剩餘回合：${status.duration}）`;

                    // 顯示圖示按鈕
                    const statusDiv = document.createElement("span");
                    statusDiv.innerHTML = `
                        <button onClick="alert('${infor}')" class="status-button">${status.icon}</button>
                    `;
                    statusList.appendChild(statusDiv);
                });

                // 關閉按鈕
                const closeButton = document.getElementById(`${member.id}-close-btn`);
                closeButton.addEventListener("click", () => {
                    document.getElementById(`${member.id}`).style.display = "none";
                });
        }

        // 顯示敵方欄位
        function showEnemy(enemy) {
            let enemies = JSON.parse(localStorage.getItem("enemies")) || [];

            const menu = document.getElementById("enemy-infor");
            
            // 創建敵人的資料
                const characterDiv = document.createElement("div");
                characterDiv.innerHTML = `
                    <div id="${enemy.id}" class="item background">
                        <div class="column-container">
                            <div class="column">
                                <h4>${enemy.adj}${enemy.name}</span></h4>
                            </div>
                            <div class="column right">
                                <h4 class="hp">${enemy.HP} / ${enemy.MaxHP}</h4>
                            </div>
                            <button id="${enemy.id}-close-btn" class="small-button" style="background: none;">×</button>
                        </div>

                        <p id="${enemy.id}-status"></p>
                        <p id="${enemy.id}-action" class="battle-text"></p>

                        ${selectedUser ? `
                            <div id="${enemy.id}-btn" class="row-buttons">
                                <button onclick="selectTarget('${enemy.id}')">⊚ <span class="small">選擇</span></button>
                            </div>
                        ` : "" }
                    </div>
                `;
                menu.appendChild(characterDiv);

                // 顯示訊息
                const message = localStorage.getItem(`${enemy.id}-action-text`) || "";
                document.getElementById(`${enemy.id}-action`).textContent = message;

                // 取得狀態圖示
                const statusList = document.getElementById(`${enemy.id}-status`);
                statusList.innerHTML = "";  // 清空選單內容
                enemy.status.forEach(status => {
                    // 生成說明文字
                    const infor = `【${status.name}】${status.description}（剩餘回合：${status.duration}）`;

                    // 顯示圖示按鈕
                    const statusDiv = document.createElement("span");
                    statusDiv.innerHTML = `
                        <button onClick="alert('${infor}')" class="status-button">${status.icon}</button>
                    `;
                    statusList.appendChild(statusDiv);
                    console.log(status.icon);
                });

                // 關閉按鈕
                const closeButton = document.getElementById(`${enemy.id}-close-btn`);
                closeButton.addEventListener("click", () => {
                    document.getElementById(`${enemy.id}`).style.display = "none";
                });

                // 如果已選為目標，加上 selected class，並隱藏按紐
                //const selectedTarget = localStorage.getItem("selectedTarget");
                //if (selectedTarget === enemy.id) {
                //    document.getElementById(`${enemy.id}`).classList.add("selected");
                //    document.getElementById(`${enemy.id}-btn`).style.display = "none";
                //}
        }


    // === 技能邏輯區 ===

        let selectedUser = null; // 使用者
        let selectedAction = null; // 動作

        // 選擇使用者
        function selectAttacker(userId, actionId) {
            selectedUser = userId;
            selectedAction = actionId;
            document.getElementById("team-note").textContent = ""; // 清除提示
            document.getElementById("enemy-note").textContent = texts.noTarget; // 顯示提示
            document.getElementById("enemy-infor").innerHTML = ""; // 清空敵人欄位
        }

        // 選擇目標
        function selectTarget(targetId) {
            if (selectedUser) {
                if (selectedAction === "talk") {
                    talk(targetId); // 交談
                } else {
                    useSkill(selectedAction, selectedUser, targetId); // 使用技能
                }
                selectedUser = null; // 重置攻擊者
                document.getElementById("enemy-note").textContent = ""; // 清除提示
            }
        }

        // 使用技能
        function useSkill(skillId, userId, targetId) {
            // 找到技能資料
            const skill = skillData.find(s => s.id === skillId);

            // 找到使用者與目標資料
            let teamMembers = JSON.parse(localStorage.getItem("teamMembers")) || [];
            let enemies = JSON.parse(localStorage.getItem("enemies")) || [];
            let allCharacters = [...teamMembers, ...enemies];
            let user = allCharacters.find(m => m.id === userId);
            let target = allCharacters.find(m => m.id === targetId);

	        // 處理使用者
	        if (userId === "team") {
		        const availableMembers = JSON.parse(localStorage.getItem("availableMembers")) || [];
		        user = createTeamUser(availableMembers); // 取得聯手使用者資料
                localStorage.setItem("availableMembers", JSON.stringify([])); // 清空可行動成員
	        } else {
                removeAvailableMembers(user.id); // 使用者移出可行動成員
            }

            // 技能結果初始化
	        const result = {
                skill: skill,
                user: user,
                target: target,
		        hit: true,
		        damage: 0,
		        userDamage: 0,
		        crit: false,
		        targetStatus: [],
		        userStatus: [],
	        };

	        // 條件判斷（如 HP <= 50%）
	        if (skill.condition && !evalCondition(skill.condition, user, target)) {
		        result.hit = false;
		        result.logs.push("條件不符合，無法使用技能。");
		        return result;
	        }

	        // MP消耗
	        if ((user.MP || 0) < (skill.cost || 0)) {
		        result.hit = false;
		        result.logs.push("MP不足");
		        return result;
	        }
	        user.MP -= skill.cost || 0;

	        // 處理自動成功的情況
	        const autoHit = 
		        parseInt(localStorage.getItem("situation")) === 4 || // 偷襲回合
		        target.type.includes("植物") || // 植物類敵人
		        Object.values(target.status).some(s => s.immobile); // 目標無法行動

	        // 命中判定
	        if (skill.hitCheck && !autoHit) {
		        const [att, def] = skill.hitCheck.split("-vs-"); // 解析屬性
		        const rollResult = roll(user[att].total, target[def].total); // 擲骰
		        result.hit = rollResult.success;
		        result.chance = rollResult.chance;
		        console.log(`使用者: ${user.name}, 使用者 ${att}: ${user[att].total}, 目標: ${target.name}, 目標 ${def}: ${target[def].total}, 命中率: ${(result.chance * 100).toFixed(1)}%`);
		        
                // 未命中，直接顯示結果
                if (!result.hit) {
                    localStorage.setItem("teamMembers", JSON.stringify(teamMembers));
                    localStorage.setItem("enemies", JSON.stringify(enemies));
                    localStorage.setItem("skillResult", JSON.stringify(result));
                    endAction(); // 動作結束
	                showSkillResult(); // 顯示結果
                }
	        }

            // 爆擊判定
            if (result.hit) {
                if (skill.critRate && skill.critRate.includes("vs")) {
                    // 骰屬性
		            const [att, def] = skill.critRate.split("-vs-"); // 解析屬性
		            const rollResult = roll(user[att].total, target[def].total); // 擲骰
		            result.crit = rollResult.success;
                } else {
                    // 骰 D20
                    rollD20 = Math.floor(Math.random() * 20) + 1;
                    result.crit = rollD20 <= skill.critRate || user.crit;
                }
            }

	        // 目標傷害（或治療）
	        if (skill.damage) {
		        result.damage = evalFormula(skill.damage, user, target);
		        target.HP = Math.min(Math.max(target.HP - result.damage, 0), target.MaxHP); // 不會低於 0 或高於最大值
		        console.log(`${user.name}擊中了${target.name}(${result.damage})！`);
	        }

	        // 自身傷害（如反彈）
	        if (skill.userDamage) {
		        result.userDamage = evalFormula(skill.userDamage, user, target);
		        user.HP = Math.min(Math.max(user.HP - result.userDamage, 0), user.MaxHP); // 不會低於 0 或高於最大值
		        console.log(`${user.name}也受傷了(${result.userDamage})！`);
	        }

	        // 目標狀態
	        if (skill.targetStatus) {
                let addStatus = true; // 預設會添加狀態
                
                // 如需過檢定
                if (skill.statusCheck) { 
		            const [att, def] = skill.statusCheck.split("-vs-"); // 解析屬性
		            const rollResult = roll(user[att].total, target[def].total); // 擲骰
		            if (!rollResult.success) addStatus = false; // 失敗不添加狀態
                }

                // 添加狀態
                if (addStatus) {
		            const status = Array.isArray(skill.targetStatus) ? skill.targetStatus : [skill.targetStatus];
		            target.status.push(...status);
		            result.targetStatus.push(...status);
		            console.log(`${target.name}${status.join("、")}了！`);
                }
	        }

	        // 自身狀態
	        if (skill.userStatus) {
		        const status = Array.isArray(skill.userStatus) ? skill.userStatus : [skill.userStatus];
		        user.status.push(...status);
		        result.userStatus.push(...status);
		        console.log(`${user.name}${status.join("、")}了！`);
	        }

	        // MP吸收
	        if (skill.mpDamage) {
		        target.MP = Math.min(Math.max(target.MP - skill.mpDamage, 0), target.MaxMP); // 不會低於 0 或高於最大值
		        console.log(`${target.name} 損失 ${skill.mpDamage} MP。`);
	        }
	        if (skill.userMpDamage) {
		        user.MP = Math.min(Math.max(user.MP - skill.userMpDamage, 0), user.MaxMP); // 不會低於 0 或高於最大值
		        console.log(`${user.name} 回復 ${-skill.userMpDamage} MP。`);
	        }

            // 儲存
            localStorage.setItem("teamMembers", JSON.stringify(teamMembers));
            localStorage.setItem("enemies", JSON.stringify(enemies));
            localStorage.setItem("skillResult", JSON.stringify(result));

            endAction(); // 動作結束
	        showSkillResult(); // 顯示結果
        }

        // 創建聯手使用者資料
        function createTeamUser(members) {
	        const teamUser = {
                id: "team",
		        name: [],
		        weapon: [],
		        dex: { total: 0 },
		        str: { total: 0 },
	        };

	        members.forEach(member => {
		        teamUser.name.push(member.name);
		        teamUser.weapon.push(member.weapon);
		        teamUser.dex.total += member.dex.total;
		        teamUser.str.total += member.str.total;
	        });

	        teamUser.name = teamUser.name.join("、");
	        return teamUser;
        }

        // 計算傷害公式
        function evalFormula(formula, user, target) {
	        // 自動補上 .total
	        const preprocessed = formula.replace(
		        /\b(user|target)\.(str|dex|con|int|wis|cha|arm)\b/g,
		        "$&.total"
	        );

            // 回傳計算結果
            return Function("user", "target", `return ${preprocessed};`)(user, target);
        }

        // 顯示技能結果
        function showSkillResult() {
            // 讀取結果
            const result = JSON.parse(localStorage.getItem("skillResult"));
            if (!result) return;

            const skill = result.skill;
            const user = result.user;
            const target = result.target;

            // 合併形容詞和名稱
            if (target.adj) target.name = target.adj + target.name;

            // 判斷 UI 容器
            let logBox;
            if (user.id === "team") {
                logBox = document.getElementById("team-action");
            } else {
                logBox = document.getElementById(`${user.id}-action`);
            }

            // 顯示命中結果
            if (result.hit) {
                logBox.innerText = skill.hitMessage // 命中
                .replace("${target.name}", target.name)
                .replace("${result.damage}", result.damage)
                .replace("${result.mpDamage}", result.mpDamage)
                .replace("${target.arm.total}", target.arm.total);
            } else {
                logBox.innerText = skill.missMessage // 未命中
                .replace("${target.name}", target.name);
                return;
            }

            // 受傷的 HP 改為紅字
            const redHP = document.getElementById(`${target.id}-HP`);
            if (redHP) redHP.classList.add("red-hp");

            // 顯示爆擊結果
            if (result.crit) {
                logBox.innerText += "造成爆擊！";
            }

            // 顯示狀態檢定結果
            if (skill.statusCheck && result.targetStatus.length > 0) {
                logBox.innerText += target.name + result.targetStatus + "了！";
            }
        }

        // 攻擊邏輯
        function fight(attacker, targetId) {
            // 獲取敵人資料
            let enemies = JSON.parse(localStorage.getItem("enemies")) || [];
            let target = enemies.find(e => e.id === targetId);
            let enemyName = target.adj + target.name;

            // 讀取可行動成員的資料
            let availableMembers = JSON.parse(localStorage.getItem("availableMembers")) || [];
          
            // 確認攻擊者人數
            if (attacker === "team") {
                // 聯手攻擊，計入所有可行動成員
                attacker = availableMembers;
            } else {
                // 單獨攻擊，找到攻擊者
                attacker = [attacker]; // 包成陣列
            }

            // 如果敵人飛行中，只計入有遠程武器的成員
            let isFly = Object.values(target.status).some(s => s.name === "飛行");
            if (isFly) {
                attacker = attacker.filter(member => member.weapon && member.weapon.category === "遠程");
            }

            // 取得攻擊者資料
            let attackerName = [], attackerDex = 0, attackerStr = 0, attackerWeapon = [];
            let jumpers = [];
            attacker.forEach(member => {
                attackerName.push(member.name);
                attackerDex += member.dex.total; // 我方總敏捷
                attackerStr += member.str.total; // 我方總力量
                attackerWeapon.push(member.weapon); // 我方武器
                jumpers.push(`${member.id}-avatar`); // 添加彈跳動畫

            });
            localStorage.setItem("jumpers", JSON.stringify(jumpers));

            // 以雙方敏捷擲骰
            let result = roll(attackerDex, target.dex.total);

            // 檢查是否有例外
            let situation = parseInt(localStorage.getItem("situation"));
            let isPlant = target.type.includes("植物");
            let isProne = Object.values(target.status).some(s => s.name === "倒地");

            if (situation === 4 || isProne || isPlant) { 
                // 如果敵人無防備、目標倒地、目標是植物，自動成功
                result = { success: true, chance: 1 };
            }
            console.log(`攻擊者: ${attackerName}, 敏捷: ${attackerDex}, 目標: ${targetId}, 目標敏捷: ${target.dex.total}`);
            console.log(`攻擊命中率: ${(result.chance*100).toFixed(2)}%`);  // 顯示精確到小數點後2位

            // 攻擊結果
            if (result.success === true) {
                // 攻擊成功，對目標造成傷害
                let damage = Math.max(attackerStr - target.arm.total, 0); // 傷害 = 我方力量總和 - 敵人護甲
                target.HP = Math.max(target.HP - damage, 0); // HP 減少，不會低於0

                // 檢查敵人是否死亡
                if (target.HP <= 0) {
                    // 敵人死亡
                    if (attackerId === "team") {
                        // 顯示聯手擊殺訊息（在隊伍的欄位）
                        document.getElementById("team-action").textContent = texts.teamKillEnemy(enemyName, damage);

                        // 雷納德添加情緒
                        if (isCompanion("雷納德")) getEmotion("雷納德", "teamwork");

                    } else {
                        // 顯示單獨擊殺訊息（在攻擊者的欄位）
                        localStorage.setItem(`${attackerId}-action-text`, texts.killEnemy(enemyName, damage));
                        showMember(singleAttacker);

                        // 塔爾穆克添加情緒
                        if (singleAttacker.name === "塔爾穆克") getEmotion("塔爾穆克", "kill");
                    }
                    // 清除目標
                    localStorage.removeItem("selectedTarget");

                } else {
                    // 敵人活著，更新顯示 HP
                    document.getElementById(`${targetId}-HP`).textContent = target.HP;

                    // HP 變為紅字（只有一個）
                    let redHP = [];
                    redHP.push(`${targetId}-HP`);
                    localStorage.setItem("redHP", JSON.stringify(redHP));

                    if (attackerId === "team") {
                        // 顯示聯手攻擊成功訊息（在隊伍的欄位）
                        localStorage.setItem(`${attackerId}-action-text`, texts.teamFightWin(enemyName, damage));

                    } else {
                        // 顯示單獨攻擊成功訊息（在攻擊者的欄位）
                        localStorage.setItem(`${attackerId}-action-text`, texts.fightWin(enemyName, damage));
                        showMember(singleAttacker);
                    }

                    // 附加狀態
                    attackerWeapon.forEach(weapon => {
                        let statusName = giveStatus(weapon, target);
                        if (statusName) {
                            // 顯示附加的訊息
                            localStorage.setItem(`${attackerId}-action-text`, texts.fightWinWithStatus(enemyName, damage, statusName));
                            showMember(singleAttacker);
                            console.log("造成" + statusName);
                        };
                    });
                };

                localStorage.setItem("enemies", JSON.stringify(enemies));  // 儲存更新後的敵人資料

            } else {
                // 攻擊失敗

                if (isFly && attackerDex === 0) {
                    // 如果失敗是因為目標在飛行，且沒有遠程武器
                    if (attackerId === "team") {
                        // 顯示聯手攻擊無法觸及訊息（在隊伍的欄位）
                        document.getElementById("team-action").textContent = texts.fightFlyingEnemy(enemyName);
                    } else {
                        // 顯示單獨攻擊無法觸及訊息（在攻擊者的欄位）
                        localStorage.setItem(`${attackerId}-action-text`, texts.fightFlyingEnemy(enemyName));
                        showMember(singleAttacker);
                    }
                    
                } else {
                    // 預設情況
                    if (attackerId === "team") {
                        // 顯示聯手攻擊失敗訊息（在隊伍的欄位）
                        document.getElementById("team-action").textContent = texts.teamFightLose(enemyName);
                    } else {
                        // 顯示單獨攻擊失敗訊息（在攻擊者的欄位）
                        localStorage.setItem(`${attackerId}-action-text`, texts.fightLose(enemyName));
                        showMember(singleAttacker);
                    }
                }
            }

            // 攻擊結束後
            if (attackerId === "team") {
                // 聯手攻擊，隱藏可行動成員的攻擊、逃跑按鈕
                availableMembers.forEach(member => {
                    document.querySelectorAll(`.${member.id}-btn button`).forEach(button => {
                        button.style.display = "none";
                    });

                    removeAvailableMembers(member.id); // 將攻擊者移出可行動成員
                });

                // 隱藏聯手攻擊、一起逃跑按鈕
                document.getElementById("team-btn").style.display = "none";
            } else {
                // 單獨攻擊，隱藏攻擊者的攻擊、逃跑按鈕
                document.querySelectorAll(`.${attackerId}-btn button`).forEach(button => {
                    button.style.display = "none";
                });

                removeAvailableMembers(attackerId); // 將攻擊者移出可行動成員
            }

            // 清除敵人的欄位
            localStorage.removeItem(`${targetId}-action-text`);
            document.getElementById("enemy-infor").innerHTML = "";

            endAction();
        }

        // 逃跑邏輯
        function escape(escaperId) {
            let presentMembers = JSON.parse(localStorage.getItem("presentMembers")) || [];
            let availableMembers = JSON.parse(localStorage.getItem("availableMembers")) || [];

            let escaperName;
            let escaperDex = 0; // 我方總敏捷
            let minDexMembers = [];
          
            if (escaperId === "team") {
                // 一起逃跑，找到 dex 最低的成員資料
                let minDex = Infinity; // 設定初始值為無限大
                availableMembers.forEach(member => {
                    if (member.dex.total < minDex) { // 如果找到更低的 dex，重置陣列，將該角色加入陣列
                        minDex = member.dex.total; // 更新最低 dex
                        minDexMembers = [member];
                    } else if (member.dex.total === minDex) {
                        minDexMembers.push(member); // 如果dex相同，將該角色加入陣列
                    }
                });
                escaperName = "一起";
                escaperDex = minDex;
            } else {
                // 單獨逃跑，找到逃跑者的資料
                singleEscaper = availableMembers.find(comp => comp.id === escaperId);
                escaperName = singleEscaper.name;
                escaperDex = singleEscaper.dex.total;
            }

            // 讀取第一個敵人的資料
            let enemies = JSON.parse(localStorage.getItem("enemies")) || [];
            let enemyDex = enemies.length > 0 ? enemies[0].dex.total : 0; // 取第一個敵人的敏捷
            let enemyType = enemies.length > 0 ? enemies[0].type : ""; // 取第一個敵人的類型
            let availableEnemies = JSON.parse(localStorage.getItem("availableEnemies")) || [];

            // 以雙方敏捷擲骰
            let result = roll(escaperDex, enemyDex);

            // 檢查是否有例外
            let situation = parseInt(localStorage.getItem("situation"));
            let isPlant = enemyType.includes("植物");
            let AllProne = enemies.filter(s => !s.status.some(s => s.name === "倒地")).length === 0;

            if (situation === 4 || isPlant ||  AllProne) { 
                // 如果敵人無防備、敵人是植物、敵人全倒地，自動成功
                result = { success: true, chance: 1 };
            } else if (escaperId !== "team" && presentMembers.length > availableEnemies.length) {
                // 如果單獨逃跑時，上場成員比可行動敵人多，敵人就無法分心追趕，自動成功
                result = { success: true, chance: 1 };
            }
            console.log(`逃跑者: ${escaperName}, 敏捷: ${escaperDex}, 敵人敏捷: ${enemyDex}`);
            console.log(`逃跑成功率: ${(result.chance*100).toFixed(2)}%`);

            // 逃跑結果
            if (result.success === true) {
                // 逃跑成功
                if (escaperId === "team") {
                    availableMembers.forEach(member => {
                        removePresentMembers(member.id); // 移出上場成員
                        addEscapeMember(member.id); // 加入逃跑成員
                    });

                    // 取得所有逃跑成員的名字並用頓號「、」分隔
                    let escapers = availableMembers.map(member => member.name).join("、");

                    // 顯示一起逃跑成功訊息
                    document.getElementById("team-action").textContent = texts.teamEscapeSuccess(escapers);
                    document.getElementById("member-infor").innerHTML = ""; // 清除欄位

                } else {
                    removePresentMembers(escaperId); // 移出上場成員
                    addEscapeMember(escaperId); // 加入逃跑成員

                    // 顯示單獨逃跑成功訊息（在逃跑者的欄位）
                    localStorage.setItem(`${escaperId}-action-text`, texts.escapeSuccess);
                    showMember(singleEscaper);

                }

            } else {
                // 逃跑失敗
                if (escaperId === "team") {
                    // 取得敏捷最低者的名字並用頓號「、」分隔
                    escapers = minDexMembers.map(member => member.name).join("、");

                    // 顯示一起逃跑失敗訊息
                    document.getElementById("team-action").textContent = texts.teamEscapeFail(escapers);
                    document.getElementById("member-infor").innerHTML = ""; // 清除欄位

                } else {
                    // 顯示單獨逃跑失敗訊息（在逃跑者的欄位）
                    //document.getElementById(`${escaperId}-action`).textContent = texts.escapeFail(escaperName);
                    localStorage.setItem(`${escaperId}-action-text`, texts.escapeFail);
                    showMember(singleEscaper);
                }
            }

            // 逃跑結束後
            if (escaperId === "team") {
                // 一起逃跑，隱藏可行動成員的攻擊、逃跑按鈕
                availableMembers.forEach(member => {
                    document.querySelectorAll(`.${member.id}-btn button`).forEach(button => {
                        button.style.display = "none";
                    });
                    //localStorage.removeItem(`${member.id}-btn-show`); // 隱藏按鈕

                    removeAvailableMembers(member.id); // 將攻擊者移出可行動成員
                });

                // 隱藏聯手攻擊和一起逃跑按鈕
                document.getElementById("team-btn").style.display = "none";
            } else {
                // 單獨攻擊，隱藏逃跑者的攻擊、逃跑按鈕
                document.querySelectorAll(`.${escaperId}-btn button`).forEach(button => {
                    button.style.display = "none";
                });
                //localStorage.removeItem(`${escaperId}-btn-show`);  // 隱藏按鈕

                removeAvailableMembers(escaperId); // 將逃跑者移出可行動成員
            }

            endAction();
        }

        // 使用物品
        function useItem(userId) {
            removeAvailableMembers(userId); // 移出可行動成員
            window.location.href = 'menu/inventory.html'; // 跳轉到物品頁面
        }

        // 走位
        function move(memberId) {
            // 讀取成員資料
            const availableMembers = JSON.parse(localStorage.getItem("availableMembers")) || [];
            const member = availableMembers.find(member => member.id === memberId);

            // 檢查成員是否在前排中
            let frontMembers = JSON.parse(localStorage.getItem("frontMembers")) || [];
            let index = frontMembers.findIndex(member => member.id === memberId);

            if (index !== -1) {
                // 如果已在前排，從前排移除
                frontMembers.splice(index, 1);
            
            } else {
                // 否則，加到前排
                frontMembers.push(member);
            }

            localStorage.setItem("frontMembers", JSON.stringify(frontMembers));
            console.log("前排成員：", frontMembers);
            generateAvatar();
            showMember(member);
        }

        // 交談
        function talk(targetId) {
            // 讀取所有敵人的資料
            let enemies = JSON.parse(localStorage.getItem("enemies")) || [];
            let enemyType = enemies.length > 0 ? enemies[0].type : ""; // 取第一個敵人的類型
            //const selectedTarget = localStorage.getItem("selectedTarget");

            // 檢查敵人類型是不是智慧
            if (enemyType.includes("智慧")) {
                //if (selectedTarget) {
                    // 如果已選擇目標，就進入交談
                    localStorage.setItem("npcId", targetId); // 儲存交談對象

                    // 隱藏主角的攻擊、逃跑按鈕
                    document.querySelectorAll("player-btn button").forEach(button => {
                        button.style.display = "none";
                    });
                    //localStorage.removeItem("player-btn-show"); // 隱藏按鈕
                    removeAvailableMembers("player"); // 將主角移出可行動成員
                    
                    window.location.href = 'battleTalk.html'; // 跳轉到交談頁面

                //} else {
                    // 如果還沒選擇目標，就顯示提示
                    //document.getElementById("enemy-note").textContent = texts.noTarget;
                //}
            } else {
                // 如果不是智慧，就顯示無法對話的提示
                document.getElementById("enemy-note").textContent = texts.cannotTalk;
            }
        }

        // 敵人攻擊邏輯
        function enemyFight() {
            // 讀取同伴資料
            let teamMembers = JSON.parse(localStorage.getItem("teamMembers"));
            let frontMembers = JSON.parse(localStorage.getItem("frontMembers")) || [];
            let presentMembers = JSON.parse(localStorage.getItem("presentMembers"));

            // 讀取第一個敵人的資料
            let enemies = JSON.parse(localStorage.getItem("enemies")) || [];
            let enemyType = enemies.length > 0 ? enemies[0].type : 0;
            let enemyDex = enemies[0].dex.total; 
            let enemyStr = enemies[0].str.total;

            // 讀取可行動敵人
            let availableEnemies = JSON.parse(localStorage.getItem("availableEnemies"))

            // 每個敵人行動
            enemies.forEach(enemy => {
                // 無法行動則中止
                let isAvailable = availableEnemies.some(e => e.id === enemy.id);
                if (!isAvailable) return;

                // 若上場成員沒人則中止（戰敗時讓玩家看情況）
                if (presentMembers.length === 0) return;

                // 添加彈跳動畫
                let jumpers = [];
                jumpers.push(`${enemy.id}-avatar`);
                localStorage.setItem("jumpers", JSON.stringify(jumpers));

                // 如果是飛行類敵人，有 20% 機率飛行
                if (enemyType.includes("飛行")) {
                    if (Math.random() <= 0.2) {
                        const fly = statusData.find(s => s.name === "飛行");
                        enemy.status.push(fly);
                        localStorage.setItem("enemies", JSON.stringify(enemies));

                        // 顯示飛行的訊息
                        localStorage.setItem(`${enemy.id}-action-text`, texts.enemyFly);
                        showEnemy(enemy);
                        return;
                    }
                }

                // 從隨機選擇一個目標
                let hurtMember;
                if (frontMembers.length > 0) {
                    // 優先從前排選擇
                    const randomIndex = Math.floor(Math.random() * frontMembers.length);
                    hurtMember = teamMembers.find(m => m.id === frontMembers[randomIndex].id);
                } else { 
                    // 如果前排無人，從上場成員中選擇
                    const randomIndex = Math.floor(Math.random() * presentMembers.length);
                    hurtMember = teamMembers.find(m => m.id === presentMembers[randomIndex].id);
                }

                // 以雙方敏捷擲骰
                let result = roll(enemyDex, hurtMember.dex.total);

                // 檢查是否有例外
                let isProne = Object.values(hurtMember.status).some(s => s.name === "倒地");
                let situation = parseInt(localStorage.getItem("situation"));

                if (situation === 4 || isProne) { 
                    // 如果目標倒地，自動成功
                    result = { success: true, chance: 1 };
                }

                console.log(`攻擊者: ${enemy.name}, 敏捷: ${enemyDex}, 目標: ${hurtMember.name}, 目標敏捷: ${hurtMember.dex.total}`);
                console.log(`計算的敵人命中率: ${(result.chance*100).toFixed(2)}%`);  // 顯示精確到小數點後2位

                // 攻擊結果
                if (result.success === true) {
                    // 敵人攻擊成功，對角色造成傷害
                    let damage = Math.max(enemyStr - hurtMember.arm.total, 0); // 傷害 = 攻擊者的力量 - 目標的護甲
                    hurtMember.HP = Math.max(hurtMember.HP - damage, 0); // HP減少，不會低於0

                    // 更新顯示 HP
                    if (document.getElementById(`${hurtMember.id}-HP`)) {
                        document.getElementById(`${hurtMember.id}-HP`).textContent = hurtMember.HP;
                    }

                    // HP變為紅字（不移除之前的紅字，可以同時有多個紅字）
                    let redHP = JSON.parse(localStorage.getItem("redHP")) || [];
                    redHP.push(`${hurtMember.id}-HP`);
                    localStorage.setItem("redHP", JSON.stringify(redHP));

                    // 判斷角色是否死亡
                    if (hurtMember.HP <= 0) {
                        // 角色死亡，顯示被擊殺訊息（在敵人的欄位）
                        localStorage.setItem(`${enemy.id}-action-text`, texts.enemyKill(hurtMember.name, damage));

                    } else {
                        // 角色活著，顯示被攻擊訊息（在敵人的欄位）
                        localStorage.setItem(`${enemy.id}-action-text`, texts.enemyWin(hurtMember.name, damage));
                        
                        // 附加狀態（來自敵人的能力或武器）
                        let statusName;
                        if (enemy.addStatus) {
                            statusName = giveStatus(enemy, hurtMember);
                        } else {
                            statusName = giveStatus(enemy.weapon, hurtMember);
                        }

                        if (statusName) {
                            // 顯示附加的訊息（在敵人的欄位）
                            localStorage.setItem(`${enemy.id}-action-text`, texts.enemyWinWithStatus(hurtMember.name, damage, statusName));
                            console.log("造成" + statusName);
                        }
                    }
                    localStorage.setItem("teamMembers", JSON.stringify(teamMembers));

                } else {
                    // 敵人攻擊失敗，顯示訊息（在敵人的欄位）
                    localStorage.setItem(`${enemy.id}-action-text`, texts.enemyLose(hurtMember.name));
                }
                showEnemy(enemy);
                endAction();
            })
        }

        // 角色離開上場成員
        function removePresentMembers(memberId) {
            let presentMembers = JSON.parse(localStorage.getItem("presentMembers")) || [];
            let index = presentMembers.findIndex(member => member.id === memberId);

            if (index !== -1) {
                let removedMember = presentMembers.splice(index, 1)[0]; // 移除並返回該成員
                //console.log(`${removedMember.name} 離開了隊伍`);
            } else {
                console.warn(`無效的同伴: ${memberId}`);
            }
            localStorage.setItem("presentMembers", JSON.stringify(presentMembers));
            //console.log("剩餘成員：", presentMembers);
        }

        // 角色離開可行動隊伍
        function removeAvailableMembers(memberId) {
            let availableMembers = JSON.parse(localStorage.getItem("availableMembers")) || [];
            let index = availableMembers.findIndex(member => member.id === memberId);

            if (index !== -1) {
                let removedMember = availableMembers.splice(index, 1)[0]; // 移除該成員
                //console.log(`${removedMember.name} 離開了隊伍`);
            } else {
                console.warn(`無效的同伴: ${memberId}`);
            }
            localStorage.setItem("availableMembers", JSON.stringify(availableMembers));
            //console.log("還沒行動過的成員：", availableMembers);
        }

        // 角色加入逃跑成員
        function addEscapeMember(escaperId) {
            // 讀取目前已逃跑的成員
            let escapeMember = JSON.parse(localStorage.getItem("escapeMember")) || [];
            
            // 讀取可行動成員的資料
            let availableMembers = JSON.parse(localStorage.getItem("availableMembers")) || [];
            
            // 找到逃跑者的資料
            let member = availableMembers.find(comp => comp.id === escaperId);

            //加入逃跑成員
            escapeMember.push(member);

            localStorage.setItem("escapeMember", JSON.stringify(escapeMember));
            console.log("已逃跑成員：", escapeMember);
        }

        // 行動結束（敵我通用）
        function endAction() {  
            let battleResult = 0;
            let respawn = 0;

            // 讀取所有敵人資料
            let enemies = JSON.parse(localStorage.getItem("enemies")) || [];

            // 如果殺死守衛，通緝等級上升，名聲下降
            enemies.forEach(enemy => {
                if (enemy.name === "守衛" && enemy.HP === 0) {
                    addWantedLevel(5);
                    addPlayerFame(-5);
                }
            });

            // 計算獻祭的靈魂數量
            enemies.forEach(enemy => {
                if (enemy.HP === 0) {
                    let soulCount = parseInt(localStorage.getItem("soulCount"));
                    soulCount ++; // 靈魂增加
                    localStorage.setItem("soulCount", soulCount);
                }
            });

            // 檢查是否執行惡魔攻擊
            const demonAttack = localStorage.getItem("demonAttack");
            if (demonAttack) {
                enemies.forEach(enemy => {
                    let damage = 10; // 傷害 = 10
                    enemy.HP = Math.max(enemy.HP - damage, 0); // HP 減少，不會低於0

                    // HP變為紅字
                    //document.getElementById(`${enemy.id}-HP`).classList.add("red-hp");
                    let redHP = [];
                    redHP.push(`${enemy.id}-HP`);
                    localStorage.setItem("redHP", JSON.stringify(redHP));

                    // 顯示敵人燃燒的描述
                    //document.getElementById(`${enemy.id}-action`).textContent = texts.demonAttacked;
                    localStorage.setItem(`${enemy.id}-action-text`, texts.demonAttacked);
                });
                localStorage.setItem("enemies", JSON.stringify(enemies)); // 儲存更新後的敵人資料
                localStorage.removeItem("demonAttack"); // 清除惡魔攻擊
            }

            // 讀取成員資料
            const teamMembers = JSON.parse(localStorage.getItem("teamMembers")) || [];
            let presentMembers = JSON.parse(localStorage.getItem("presentMembers")) || [];
            let availableMembers = JSON.parse(localStorage.getItem("availableMembers")) || [];
            let frontMembers = JSON.parse(localStorage.getItem("frontMembers")) || [];
            let escapeMember = JSON.parse(localStorage.getItem("escapeMember")) || [];

            // 同步更新角色 HP、狀態
            [presentMembers, availableMembers, frontMembers].forEach(array =>{
                array.forEach(member => {
                    let existingMember = teamMembers.find(m => m.id === member.id);
                    if (existingMember) {
                        member.HP = existingMember.HP;
                        member.status = existingMember.status;
                    }
                });
            });

            // 根據角色 HP 更新情緒
            teamMembers.forEach(member => {
                if (member.HP === member.MaxHP) {
                    getEmotion(member.id, "fullHP");
                } else {
                    loseEmotion(member.id, "fullHP");
                }
            });

            // 檢查是否有角色死亡
            let deadMembers = presentMembers.filter(member => member.HP <= 0);
            if (deadMembers.length) {
                // 顯示死亡訊息（可顯示多人）
                let deadMemberNames = deadMembers.map(member => member.name).join("、");
                document.getElementById("team-action").textContent = texts.die(deadMemberNames); // 顯示死亡訊息

                // 遍歷死亡角色，添加情緒
                deadMembers.forEach(member => {
                    getEmotion(member.id, "knockedDown");
                });

                // 如果主角死亡，雷納德添加情緒
                let playerDead = deadMembers.some(member => member.id === "player");
                if (playerDead && isCompanion("雷納德")) {
                    getEmotion("雷納德", "selfBlame");
                }
            }

            // 檢查角色是否非死即逃
            if (presentMembers.length > 0) { // 檢查上場成員是否有人（如果沒人，有可能是全員逃走）
                let allMembersDead = presentMembers.every(member => member.HP <= 0); // 檢查上場成員是否都死亡
                if (allMembersDead) {
                    if (escapeMember.length > 0) { // 檢查逃跑成員是否有人
                        // 有人死亡，剩下的人都已逃走
                        battleResult = 3;
                        localStorage.setItem("battleResult", battleResult);
                        return; // 防止繼續執行後面的邏輯
                    }
                }
            }

            // 移除死亡角色，只保留HP大於0的角色
            presentMembers = presentMembers.filter(member => member.HP > 0); 
            availableMembers = availableMembers.filter(member => member.HP > 0); 
            frontMembers = frontMembers.filter(member => member.HP > 0); 
            localStorage.setItem("presentMembers", JSON.stringify(presentMembers));
            localStorage.setItem("availableMembers", JSON.stringify(availableMembers));
            localStorage.setItem("frontMembers", JSON.stringify(frontMembers));
            localStorage.removeItem("deadMembers");
            
            //console.log("剩餘成員:", presentMembers);
            //console.log("可行動的成員", availableMembers);

            // 檢查隊伍是否全滅
            if (presentMembers.length === 0) { // 檢查上場成員是否 0 人
                if (escapeMember.length === 0) { // 檢查逃跑成員是否 0 人
                    // 全員死亡
                    generateAvatar(); // 更新顯示圖像
                    defeated();
                } else {
                    // 全員逃走
                    battleResult = 2;
                    localStorage.setItem("battleResult", battleResult);
                    localStorage.removeItem("inEvent"); // 清除事件
                    endBattle();
                }
                return; // 防止繼續執行後面的邏輯
            }

            // 檢查敵人是否全滅
            if (enemies.every(enemy => enemy.HP <= 0)) {
                // 戰鬥勝利
                loot();
                battleResult = 1;
                localStorage.setItem("battleResult", battleResult);
                turnSwitch(); // 如果有觸發開關，將開關打開

                // 如果有指定戰勝後的對話
                const encounter = JSON.parse(localStorage.getItem("encounter")) || [];
                if (encounter && encounter.successKey) {
                    localStorage.setItem("currentKey", encounter.successKey);
                }

                // 添加戰勝的情緒
                presentMembers.forEach(member => {
                    getEmotion(member.id, "battleWin");
                })

                endBattle();
            }

            // 檢查是否搶劫敵人
            let robEnemy = localStorage.getItem("robEnemy") === "true"; 
            if (robEnemy) {
                // 搶劫敵人
                loot();
                battleResult = 4;
                localStorage.setItem("battleResult", battleResult);
                endBattle();
            }

            // 檢查是否拒絕敵人投降
            if (isTrue("拒絕投降")) {
                turnSwitch("拒絕投降", false);
                newRound();
            }

            // 移除死亡的敵人
            enemies = enemies.filter(enemy => enemy.HP > 0); // 只保留HP大於0的敵人
            localStorage.setItem("enemies", JSON.stringify(enemies)); // 更新localStorage中的敵人資料
            generateAvatar(); // 更新顯示圖像
        }

        // 回合結束
        function endRound() {
            let teamMembers = JSON.parse(localStorage.getItem("teamMembers")) || [];
            let presentMembers = JSON.parse(localStorage.getItem("presentMembers")) || [];

            // 移除標題、我方欄位、隊伍訊息
            document.getElementById("situation").textContent = "";
            document.getElementById("member-infor").innerHTML = "";
            document.getElementById("team-action").textContent = "";

            // 移除戰鬥訊息
            document.querySelectorAll(".battle-text").forEach(el => el.textContent = "");
            teamMembers.forEach(member => {
                localStorage.removeItem(`${member.id}-action-text`);
            });

            // 移除HP的紅字
            for (const el of document.querySelectorAll(".red-hp")) el.classList.remove("red-hp");
            localStorage.removeItem("redHP");

            // 角色的狀態減少持續回合
            teamMembers.forEach(member => {    
                member.status.forEach(s => {
                    s.duration --; // 減少持續回合
                });

                // 移除已結束的狀態
                member.status = member.status.filter(s => s.duration > 0);
            });

            // 儲存更新後的資料
            localStorage.setItem("teamMembers", JSON.stringify(teamMembers));


            // 判斷是否已經戰敗（因為戰勝的話，會直接在行動結束時跳轉，戰敗的話，要先讓玩家看一下發生什麼事，然後按下「回合結束」後才跳轉）
            battleResult = localStorage.getItem("battleResult");
            if (battleResult && (battleResult !== 1 || battleResult !== 2 || battleResult !== 4)) {
                localStorage.removeItem("inEvent"); // 清除事件
                endBattle();
                return;
            }
            
            // 檢查俘虜是否逃跑
                // 獲取俘虜、非俘虜成員的資料
                const prisoners = presentMembers.filter(member => member.type === "俘虜");
                const nonPrisoners = presentMembers.filter(member => member.type !== "俘虜");
   
                // 加總敏捷
                let teamDex = 0;
                nonPrisoners.forEach(member => {
                    teamDex += member.dex.total;
                });

                // 檢查每個俘虜
                prisoners.forEach(member => {
                    // 以雙方敏捷擲骰
                    let result = roll(member.dex.total, teamDex);
                    console.log(`俘虜敏捷: ${member.dex.total}, 隊伍總敏捷: ${teamDex}`);
                    console.log(`俘虜逃跑機率: ${(result.chance*100).toFixed(2)}%`);  // 顯示精確到小數點後2位

                    // 結果
                    if (result.success === true) {
                        // 俘虜逃跑
                        removePresentMembers(member.id); // 移出上場成員
                        removeCompanion(member.id); // 移出隊伍

                        // 顯示俘虜逃跑訊息（顯示在隊伍欄位，因為逃跑成功會清除角色欄位）
                        document.getElementById("team-action").textContent = texts.escapePrisoner(member.name);
                    }
                });

            // 讀取敵人資料
            let enemies = JSON.parse(localStorage.getItem("enemies")) || [];
            let enemyType = enemies.length > 0 ? enemies[0].type : 0;

            // 先將所有敵人加入可行動敵人
            let availableEnemies = [...enemies];  // 使用擴展語法確保actabeEnemies獨立於enemies

            // 每個敵人的狀態生效，並減少持續回合
            enemies.forEach(enemy => {
                // 先重置屬性
                ["str", "dex", "con", "int", "wis", "cha", "arm"].forEach(attr => {
                    enemy[attr].status = 0;
                    enemy[attr].total = Object.entries(enemy[attr])
                        .filter(([key]) => key !== "total" && key !== "status") // 過濾掉 "total" 和 "status"
                        .reduce((sum, [, val]) => sum + val, 0); // 累加數值
                });

                // 狀態效果
                enemy.status.forEach(s => {
                    // HP 增減（確保不會超過最大值，也不會小於0）
                    enemy.HP = Math.min(Math.max(enemy.HP + (s.HP || 0), 0), enemy.MaxHP);

                    // 屬性增減
                    ["str", "dex", "con", "int", "wis", "cha", "arm"].forEach(attr => {
                        enemy[attr].status += s[attr] || 0;  // 更新 status 屬性
                        enemy[attr].total += s[attr] || 0;    // 更新 total 屬性
                    });

                    // 無法行動
                    if (s.immobile) {
                        // 移出可行動敵人
                        const targetIndex = availableEnemies.findIndex(e => e.id === enemy.id);
                        if (targetIndex > -1) {
                            availableEnemies.splice(targetIndex, 1);
                        }

                        // 顯示狀態訊息
                        if (s.name === "倒地") {
                            localStorage.setItem(`${enemy.id}-action-text`, texts.prone);
                        } if (s.name === "石化") {
                            localStorage.setItem(`${enemy.id}-action-text`, texts.petrified);
                        }
                    }
                    
                    s.duration --; // 減少持續回合
                });

                // 移除已結束的狀態
                enemy.status = enemy.status.filter(s => s.duration > 0);
            });

            // 儲存更新後的敵人資料
            localStorage.setItem("enemies", JSON.stringify(enemies));
            localStorage.setItem("availableEnemies", JSON.stringify(availableEnemies));

            // 如果敵人毫無防備，下回合恢復正常回合
            let situation = parseInt(localStorage.getItem("situation"));
            if (situation === 4) {
                localStorage.removeItem("situation"); // 清除遇敵方式
            }

            // --------------------------------
            // 敵人回合
            // --------------------------------
            
            document.getElementById("enemy-infor").innerHTML = ""; // 先清空敵人欄位
            // 檢查敵人是否投降
                // 找到 str 最高的成員
                let maxStrMembers = [];
                let maxStr = -Infinity; // 設定初始值為負無限
                presentMembers.forEach(member => {
                    if (member.str.total > maxStr) { // 如果找到更高的 str，重置陣列，將該角色加入陣列
                        maxStr = member.str.total; //更新最高 str
                        maxStrMembers = [member];
                    }
                });

                // 敵人是否投降
                if (enemies.length === 1 && enemyType.includes("智慧") && maxStr > enemies[0].HP && !isTrue("enemySurrender")) {
                    // 如果只剩一個智慧敵人，且隊伍中最高力量 > 敵人 HP 時，且還沒投降過
                        
                    // 以雙方力量擲骰
                    let result = roll(maxStr, enemies[0].str.total);
                    console.log(`隊伍最高力量: ${maxStr}, 敵人力量: ${enemies[0].str.total}`);
                    console.log(`投降機率: ${(result.chance*100).toFixed(2)}%`);  // 顯示精確到小數點後2位

                    // 結果
                    if (result.success === true) {
                        turnSwitch("enemySurrender");
                        localStorage.setItem("npcId", enemies[0].id); // 儲存為交談對象
                        window.location.href = 'battleTalk.html'; // 敵人投降，跳轉到交談頁面
                        return;
                    }
                }

            enemyFight(); // 敵人攻擊
            newRound(); // 新的回合開始
        }

        // 新的回合開始
        function newRound() {
            let teamMembers = JSON.parse(localStorage.getItem("teamMembers")) || [];
            let presentMembers = JSON.parse(localStorage.getItem("presentMembers")) || [];

            // 先將所有上場成員加入可行動成員
            let availableMembers = [...presentMembers];  // 使用擴展語法確保availableMembers獨立於presentMembers

            // 角色的狀態生效
            teamMembers.forEach(member => {
                // 先重置屬性
                ["str", "dex", "con", "int", "wis", "cha", "arm"].forEach(attr => {
                    member[attr].status = 0;
                    member[attr].total = Object.entries(member[attr])
                        .filter(([key]) => key !== "total" && key !== "status") // 過濾掉 "total" 和 "status"
                        .reduce((sum, [, val]) => sum + val, 0); // 累加數值
                });

                // 狀態效果
                member.status.forEach(s => {
                    // HP 增減（確保不會超過最大值，也不會小於0）
                    member.HP = Math.min(Math.max(member.HP + (s.HP || 0), 0), member.MaxHP);

                    // 屬性增減
                    ["str", "dex", "con", "int", "wis", "cha", "arm"].forEach(attr => {
                        member[attr].status += s[attr] || 0;  // 更新 status 屬性
                        member[attr].total += s[attr] || 0;    // 更新 total 屬性
                    });

                    // 無法行動
                    if (s.immobile) {
                        // 移出可行動成員
                        const targetIndex = availableMembers.findIndex(e => e.id === member.id);
                        if (targetIndex > -1) {
                            availableMembers.splice(targetIndex, 1);
                        }

                        // 顯示狀態訊息
                        if (s.name === "倒地") {
                            localStorage.setItem(`${member.id}-action-text`, texts.prone);
                        } if (s.name === "石化") {
                            localStorage.setItem(`${member.id}-action-text`, texts.petrified);
                        }
                    }
                });
            });

            // 儲存更新後的資料
            localStorage.setItem("teamMembers", JSON.stringify(teamMembers));
            localStorage.setItem("availableMembers", JSON.stringify(availableMembers));
            endAction();

            // 檢查雷納德是否路過幫忙
                isMember = teamMembers.some(m => m.name === "雷納德");
                const inEvent = localStorage.getItem("inEvent");

                if (!isMember && teamMembers.length < 4 && teamMembers.length > 0 && !inEvent && !isTrue("雷納德路過")) {
                    // 如果雷納德不在隊伍中，隊伍有空位，且不是在事件中，且今天還沒遇過雷納德，雷納德有機率加入
                    let randomValue = Math.random();
                    if (randomValue <= 0.05) { // 5% 機率加入
                        turnSwitch("雷納德路過");
                        localStorage.setItem("npcName", "雷納德");
                        showDialogue("雷納德幫忙");
                    }
                }

            generateAvatar(); // 更新顯示圖像

            window.scrollTo({ top: 0, behavior: "smooth" }); // 跳到畫面上方
        }

        // 獲得金錢和戰利品
        function loot() {
            // 讀取所有敵人的資料
            let enemies = JSON.parse(localStorage.getItem("enemies")) || [];

            // 讀取初始敵人數量
            let enemyCount = parseInt(localStorage.getItem("enemyCount"));
                
            // 讀取玩家的金錢與物品
            let playerMoney = parseInt(localStorage.getItem("playerMoney")) || 0;
            let playerItems = JSON.parse(localStorage.getItem("playerItems")) || [];

            let totalMoney = 0;
            let totalLoot = [];

            // 計算金錢和戰利品
            enemies.forEach(enemy => {
                // 金錢
                if (enemy.money) {
                    totalMoney += enemy.money * enemyCount;
                    playerMoney += enemy.money * enemyCount;
                }
                // 戰利品（一般戰利品 + 武器 + 護甲）
                for (let i = 0; i < enemyCount; i++) {
                    // 戰利品
                    if (enemy.loot) {
                        if (Array.isArray(enemy.loot)) {
                            totalLoot = totalLoot.concat(enemy.loot); // 如果 enemy.loot 是陣列，將其所有物品加入 totalLoot
                        } else {
                            totalLoot.push(enemy.loot); // 如果只有一個物品，直接加入
                        }
                    }
                    // 武器和護甲
                    if (enemy.weapon.id) totalLoot.push(enemy.weapon.id);
                    if (enemy.armor.id) totalLoot.push(enemy.armor.id);
                }
            });

            // 更新玩家金錢與物品
            playerItems = playerItems.concat(totalLoot);
            localStorage.setItem("playerItems", JSON.stringify(playerItems));
            localStorage.setItem("playerMoney", playerMoney);

            // 統計戰利品的數量
            let lootCount = totalLoot.reduce((count, loot) => {
                count[loot] = (count[loot] || 0) + 1;
                return count;
            }, {});

            // 顯示獲得的金錢和戰利品
            let lootResult;

            // 獲得的金錢
            let moneyText = totalMoney > 0 ? `獲得 🪙 $${totalMoney}<br>` : "";

            // 獲得的戰利品
            let lootText = Object.keys(lootCount).map(loot => {
                //let item = itemDatabase.find(i => i.id === loot);
                let item = findItemData(loot); // 從資料庫查找物品
                return item ? `獲得 ${item.name} × ${lootCount[loot]}` : "";
            }).filter(text => text !== "").join("<br>");

            lootResult = moneyText + lootText;
            localStorage.setItem("lootResult", lootResult);
        }

        // 戰敗後的處理
        function defeated() {
            // 讀取第一個敵人的類型
            let enemies = JSON.parse(localStorage.getItem("enemies")) || [];
            let enemyType = enemies.length > 0 ? enemies[0].type : 0;

            // 讀取目前已逃跑的成員
            let escapeMember = JSON.parse(localStorage.getItem("escapeMember")) || [];
            let playerEscaped = escapeMember.some(member => member.id === "player");

            const encounter = JSON.parse(localStorage.getItem("encounter"));

            // 決定戰敗的情況
            if (enemyType.includes("類人") && !playerEscaped && !encounter) {
                // 如果是類人敵人、主角沒有逃走，也不是指定戰鬥，就隨機決定情況
                let randomValue = Math.random();

                if (randomValue < 1) { // 100% 被搶劫
                    battleResult = 6;
                } else { // 0% 被抓去當奴隸（尚未實裝）
                    battleResult = 8; 
                }                
                localStorage.setItem("battleResult", battleResult);

            } else { 
                // 否則單純被擊倒
                battleResult = 5;
                localStorage.setItem("battleResult", battleResult);
            }
            
            // 處理戰敗的情況
            if (battleResult === 6) { // 被搶劫的情況
                // 讀取主角金錢
                let playerMoney = parseInt(localStorage.getItem("playerMoney")) || 0;

                // 如果有錢，執行搶劫
                if (playerMoney > 0) {
                    // 隨機決定被搶走的金額（至少 1，最多一半）
                    let robbedMoney = Math.max(1, Math.floor(Math.random() * playerMoney * 0.5));
                    robbedMoney = Math.min(robbedMoney, playerMoney); // 確保不會超過擁有的金額

                    // 扣除金錢並儲存
                    playerMoney -= robbedMoney;
                    localStorage.setItem("playerMoney", playerMoney);
                    localStorage.setItem("robbedMoney", robbedMoney);

                } else {
                    // 沒有錢，改為普通擊倒
                    battleResult = 5;
                    localStorage.setItem("battleResult", battleResult);
                }

            } else if (battleResult === 8) { // 成為奴隸的情況（尚未實裝）

            }

            // 檢查有沒有包裹，隨機損壞一件
                let playerItems = JSON.parse(localStorage.getItem("playerItems")) || [];
                let packages = playerItems.filter(item => item === "package01" || item === "package02");

                if (packages.length > 0) {
                    // 隨機選擇一件包裹
                    let randomPackage = packages[Math.floor(Math.random() * packages.length)];

                    // 根據這個包裹的id替換為損壞包裹
                    playerItems = playerItems.map(item => {
                        if (item === randomPackage) {
                            return randomPackage === "package01" ? "package01_damaged" : "package02_damaged"; // 替換為損壞版本
                        }
                        return item; // 保留其他包裹不變
                    });

                    // 更新 localStorage
                    localStorage.setItem("playerItems", JSON.stringify(playerItems));
                }

            // 如果有指定戰敗後的對話
            if (encounter && encounter.failKey) {
                localStorage.setItem("currentKey", encounter.failKey);
            } else {
                localStorage.removeItem("inEvent"); // 清除事件
            }
                
            turnSwitch("幫助平民", false); // 清除幫助平民

            // 隨機決定重生的情況
            let respawn;
            let randomValue = Math.random();
            if (randomValue < 0.5) { // 50% 原地重生
                respawn = 1; 
            } else { // 50% 被送回城鎮
                respawn = 2; 
            }

            // 如果在事件中，只會原地重生
            const inEvent = localStorage.getItem("inEvent");
            if (inEvent) {
                respawn = 1; 
            }
            
            // 如果指定敵人是守衛，就會被逮捕
            if (encounter && encounter.enemyName === "守衛") {
                respawn = 3; // 在監獄重生
            }

            // 儲存重生的情況
            localStorage.setItem("respawn", respawn);
        }

        // 戰鬥結束
        function endBattle() {  
            window.location.href = 'battleResult.html'; // 跳轉到戰鬥結果頁面
        }

        // 幫手加入
        function helperJoin() {
            // 加入隊伍
            const npcName = localStorage.getItem("npcName");
            let companion = mercenaries.find(comp => comp.name === npcName);
            addCompanion(companion);

            // 找到隊中的id
            const teamMembers = JSON.parse(localStorage.getItem("teamMembers")) || [];
            let member = teamMembers.find(m => m.name === npcName);

            // 加入上場成員、可行動成員
            let presentMembers = JSON.parse(localStorage.getItem("presentMembers")) || [];
            let availableMembers = JSON.parse(localStorage.getItem("availableMembers")) || [];
            presentMembers.push(member);
            availableMembers.push(member);
            localStorage.setItem("presentMembers", JSON.stringify(presentMembers));
            localStorage.setItem("availableMembers", JSON.stringify(availableMembers));

            generateAvatar(); // 更新顯示圖像
        }

        // 附加狀態
        function giveStatus(weapon, target) {
            if (weapon && weapon.addStatus) {
                // 用武器的附加機率擲骰（不用過屬性檢定）
                let success = Math.random() <= weapon.addChance;
                console.log(`狀態附加成功率: ${(weapon.addChance*100)}%`);
                
                // 附加成功
                if (success) {
                    let status = statusData.find(sta => sta.name === weapon.addStatus);
                    target.status.push(status);
                    return status.name;
                }
            }
        }

    </script>

</body>
</html>
