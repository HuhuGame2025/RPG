<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>戰鬥</title>
    <link rel="stylesheet" href="style.css">
    <style>

    /* 區塊 */

        body {
            display: flex;
            flex-direction: column;
        }

        /* 主要區域 */
        #main {
            position: relative;
            flex: 1;
        }

        /* 絕對位置的物件 */
        #enemy-container, #member-container, #enemy-infor, #member-infor, #menu {
            position: absolute;
            width: 100%;
        }

        /* 我方、敵方區域 */
        #member-container, #enemy-container {
            height: 30%;
            display: flex;
            flex-direction: column; /* 讓內容物直向排列 */
            vertical-align: middle;
        }
        #member-container { /* 我方區域 */
            top: 40%;
        }
        #enemy-container { /* 敵方區域 */
            bottom: 60%;
        }

        /* 排 */
        .row {
            display: flex;
            margin: auto 0;
        }

        /* 我方、敵方欄位 */
        #member-infor, #enemy-infor {
        }

        .background {
            background: #000;
            box-shadow: 0 0 5px rgba(255, 255, 255, 0.4); /* 光暈 */
        }

        /* 下排按鈕 */
        #menu {
            bottom: 70px; /* 至少要 50px 才看得到*/
            margin: 0;
        }

        .item {
            margin: 10px 0;
        }

        /* 可行動成員 */
        .availableMembers {
            border: 1px solid rgba(255, 255, 255, 1); /* 白框 */
            color: #fff;
        }

        /* 武器圖示 */
        .weapon-icon {
            border-radius: 50%;
            box-shadow: 0 0 5px rgba(255, 255, 255, 0.8); /* 光暈 */
            width: 40px;
            height: 40px;
            padding: 0;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* HP 受到攻擊後變成紅字 */
        .red-hp {
            color: red;
            font-weight: bold;
        }

        /* 狀態圖示按鈕 */
        .status-button {
            font-size: 0.7em;
            margin: 0;
            padding: 0;
            background: none;
        }

        /* 戰鬥訊息 */
        .battle-text {
            font-size: 0.9em;
            color: #999;
        }

    /* 按鈕 */

        /* 動作選單 */
        .action-buttons {
            display: flex;
            justify-content: center; /* 水平置中，要配合 display: flex */
        }

        /* 動作按鈕 */
        .action-buttons button {
            display: inline-block;
            flex: none;
            width: 30%;
            height: auto;
            background: #000;
            margin: 5px;
            padding: 0;
            text-align: center;
        }

        /* 動作圖示 */
        .action-icon {
            border: 1px solid #555; /* 白框 */
            border-radius: 5px;
            width: 2em;
            height: 2em;
            display: flex;
            justify-content: center; /* 水平置中，要配合 display: flex */
            align-items: center; /* 垂直置中，要配合 display: flex */
            margin: auto;
        }

        /* 技能圖示 */
        #row-3 .action-icon {
            border: 1px solid #97600f; /* 金框 */
        }
        #row-3 span {
            color: #d38511; /* 金字 */
        }

        /* 禁用的圖示 */
        #row-3 .disable .action-icon {
            border: 1px solid #333; /* 灰框 */
        }
        .disable span {
            color: #666 !important; /* 灰字 */
        }

        /* 目標按鈕*/
        #target-menu .action-icon {
            border: none;
        }

        /* 前進、後退按鈕 */
        .move-btn {
            color: #666;
            background: none;
            margin: auto;
            padding: 0;
            display: block;
        }

    </style>
</head>
<body>
    <!-- 按鈕列 -->
    <div id="buttonBar"></div>

    <!-- 通知框 -->
    <div id="toast-container"></div>

    <!-- 主要內容區域 -->
    <div id="main" class="main-content">
        <!-- 標題、提示 -->
        <h3 id="title" class="center"></h3>
        <p id="text" class="center"></p>

        <div id="battle-content">
            <!-- 敵人列表 -->
            <div id="enemy-container">
                <div id="backEnemies-row" class="row"></div>
                <div id="frontEnemies-row" class="row"></div>

                <p class="small column-container bottomborder">
                    <span class="column"></span>
                    <span class="note center" id="enemy-note">　</span>
                    <span class="column right">➴ 敵方</span>
                </p>
            </div>

            <!-- 我方列表 -->
            <div id="member-container">
                <p class="small column-container">
                    <span class="column left">我方 ➶</span>
                    <span class="note center" id="team-note">　</span>
                    <span class="column"></span>
                </p>
                <p id="soul-count"></p>

                <div id="frontMembers-row" class="row"></div>
                <div id="backMembers-row" class="row"></div>
            </div>
        </div>

        <div id="enemy-infor"></div>
        <div id="member-infor"></div>

        <div class="menu" id="menu">
            <button id="end-btn" onclick="endRound()">結束回合</button>
            <button id="next-btn" onclick="enemyAction()" class="hide">下一個敵人</button>
        </div>
    </div>

    <!-- 對話區域 -->
    <div id="dialogue" class="main-content"></div>

    <script src="script.js"></script>
    <script>

        // 顯示文本
        const texts = {
            noTarget: "選擇目標",
            noAttacker: "請選擇我方角色的行動",
            fightWin: (name, damage) => `擊中${name}(${damage})！`,
            fightWinWithStatus: (name, damage, status) => `擊中${name}(${damage})，使他${status}了！`,
            fightLose: (name) => `試圖攻擊${name}，但被躲開了`,
            fightFlyingEnemy: (name) => `${name}飛得太高，無法擊中`,
            killEnemy: (name, damage) => `打敗了${name}(${damage})！`,
            die: (deadMembers) => `${deadMembers}倒下了！`,
            teamFightWin: (name, damage) => `你們聯手，對${name}造成了重創！(${damage})`,
            teamFightLose: (name) => `${name}非常頑強，避開了所有的攻擊`,
            teamKillEnemy: (name, damage) => `你們聯手打敗${name}(${damage})！`,
            escapeSuccess: "順利逃走了",
            escapeFail: "逃跑時被敵人阻擋了！",
            teamEscapeSuccess: (name) => `${name}逃走了`,
            teamEscapeFail: (name) => `${name}跑不過敵人，你們只好停下來！`,
            enemyWin: (name, damage) => `擊中${name}(${damage})！`,
            enemyWinWithStatus: (name, damage, status) => `擊中${name}(${damage})，使他${status}了！`,
            enemyLose: (name) => `試圖攻擊${name}，但被躲開了`,
            enemyKill: (name, damage) => `打敗了${name}(${damage})！`,
            enemyFly: "飛上了高空",
            safe: "順利前進",
            battle: "敵人出現了！",
            surprise: "遭到偷襲了！",
            cannotTalk: "敵人無法理解你說的話。",
            escapePrisoner: (name) => `${name}趁你在對付敵人時逃走了！`,
            demonAttacked: "燃燒了起來",
            bleeding: "流血了",
            prone: "從地上起身",
            petrified: "變成石頭，無法動彈",
            //trap: "觸發陷阱！",
            //enemyComing: "敵人正在趕來的路上，最好快點離開",
        };

        // 畫面載入時
        window.onload = function() {
            getSituation(); // 讀取並執行遇敵方式
            turnSwitch("inBattle"); // 標記為戰鬥中

            preferences(); // 偏好設定
            showButtonBar(); // 顯示按鈕列
            loadBackground(); // 讀取背景
        };

        // 對話資料庫
        const dialogueData = {
            "雷納德": {
                "雷納德幫忙": {
                    npc: "npc",
                    text: "沒事吧？你需要幫忙嗎？",
                    choices: [
                        { text: "拜託了", next: "", action: "(helperJoin(), removeDialogue(), getSituation())" },
                        { text: "不用幫忙", next: "", action: "(removeDialogue(), getSituation())" },
                    ]
                },
            },
        }

    // === 顯示區 ===

        let enemy = {}; // 當前敵人
        let escapeMember= []; // 逃跑成員

        // 處理遇敵方式
        function getSituation() {
            let enemies = JSON.parse(localStorage.getItem("enemies")) || [];
            let situation = parseInt(localStorage.getItem("situation"));
            const title = document.getElementById("title"); // 標題顯示位置

            // 一般回合(2)、攻擊跟蹤者(5)、拯救路人(7)
            if (situation === 2 || situation === 5 || situation === 7) {
                // 儲存敵人準備戰鬥的描述
                enemies.forEach(enemy => {
                    localStorage.setItem(`${enemy.id}-action-text`, enemy.actionBattle);
                });

                title.textContent = texts.battle; // 顯示標題
                localStorage.removeItem("situation"); // 清除遇敵方式
                console.log("一般遇敵（我方先攻）");

            // 被偷襲(3)
            } else if (situation === 3) {
                title.textContent = texts.surprise; // 顯示標題
                localStorage.removeItem("situation"); // 清除遇敵方式
                endAction() // 開始戰鬥，初始化
                enemyAction(); // 敵人攻擊
                console.log("被偷襲（敵人先攻）");

            // 敵人無防備(4)
            } else if (situation === 4) {
                // 儲存敵人無防備的描述
                enemies.forEach(enemy => {
                    localStorage.setItem(`${enemy.id}-action-text`, enemy.action);
                });
                console.log("發現無防備的敵人（我方第一回合攻擊、逃跑100%成功）");
            }
            endAction() // 開始戰鬥，初始化
        }

        // 顯示戰鬥圖像
        function generateAvatar() {
            // 讀取資料
            const presentMembers = JSON.parse(localStorage.getItem("presentMembers")) || [];
            const availableMembers = JSON.parse(localStorage.getItem("availableMembers")) || [];
            const frontMembers = JSON.parse(localStorage.getItem("frontMembers")) || [];
            const enemies = JSON.parse(localStorage.getItem("enemies")) || [];
            const frontEnemies = JSON.parse(localStorage.getItem("frontEnemies")) || [];

            // 獲取列表容器
            const backEnemiesRow = document.getElementById("backEnemies-row");
            backEnemiesRow.innerHTML = "";
            const frontEnemiesRow = document.getElementById("frontEnemies-row");
            frontEnemiesRow.innerHTML = "";
            const frontMembersRow = document.getElementById("frontMembers-row");
            frontMembersRow.innerHTML = "";
            const backMembersRow = document.getElementById("backMembers-row");
            backMembersRow.innerHTML = "";

            // 創建每個角色的圖像
            const allCharacters = [...presentMembers, ...enemies];
            allCharacters.forEach(character => {
                const characterDiv = document.createElement("div");
                characterDiv.style.margin = "auto";
                characterDiv.innerHTML = `
                    <button id="${character.id}-avatar" class="avatar background">
                        <span class="small note">
                            ${character.adj ? `${character.adj}<br>` : ""}${character.name}
                        </span>
                    </button>
                    <div class="center small">
                        <h4 class="hp">
                            ${character.tempHP ? `${character.tempHP} + ` : "" }
                            <span id="${character.id}-HP">${character.HP}</span> / ${character.MaxHP}
                        </h4>
                    </div>
                `;

                // 按下圖像時
                characterDiv.addEventListener("click", () => {
                    document.getElementById("member-infor").innerHTML = ""; // 清除隊友欄位
                    document.getElementById("enemy-infor").innerHTML = ""; // 清除敵人欄位
                    showInfor(character); // 顯示欄位
                });

                // 分配圖像位置
                if (frontMembers.some(m => m.id === character.id)) {
                    frontMembersRow.appendChild(characterDiv); // 前排隊友
                } else if (presentMembers.some(m => m.id === character.id)) {
                    backMembersRow.appendChild(characterDiv); // 後排隊友
                } else if (frontEnemies.some(m => m.id === character.id)) {
                    frontEnemiesRow.appendChild(characterDiv); // 前排敵人
                } else {
                    backEnemiesRow.appendChild(characterDiv); // 後排敵人
                }

                // 顯示前進、後退按鈕
                if (!character.id.startsWith("enemy")) { 
                    const isFront = frontMembers.some(m => m.id === character.id);
                    if (!isFront) {
                        characterDiv.insertAdjacentHTML("afterbegin", `
                            <button class="move-btn" onclick="move('${character.id}')">⇑</button>
                        `);
                    } else {
                        characterDiv.insertAdjacentHTML("beforeend", `
                            <button class="move-btn" onclick="move('${character.id}')">⇓</button>
                        `);
                    }
                }
            });

            // 標記可行動成員（白框）
            availableMembers.forEach(member => {
                document.getElementById(`${member.id}-avatar`).classList.add("availableMembers");
            });

            // 顯示或隱藏選擇角色的提示
            const tip = document.getElementById("team-note");
            tip.textContent = availableMembers.length > 0 ? texts.noAttacker : "";

            // 如果有可用的紅寶石，就顯示已獻祭的數量
            if (hasItem("devilGem02")) {
                const soulCount = parseInt(localStorage.getItem("soulCount"));
                document.getElementById('soul-count').textContent = "💀 " + soulCount;
            }
            
            console.log("敵人:", enemies);
            console.log("可行動的成員", availableMembers);
        }

        // 顯示角色欄位
        function showInfor(character) {
            // 顯示武器圖示
            let weaponIcon = ""; // 預設無圖示
            if (character.weapon && character.weapon.id) {
                weaponIcon = Array.from(character.weapon.name).slice(0, 2).join(""); // 取前兩個字符（emoji）
            }

            // 顯示角色訊息
            const message = localStorage.getItem(`${character.id}-action-text`) || "";
            
            // 判斷敵我
            const isEnemy = character.id.startsWith("enemy");
            let characterDiv;
            if (isEnemy) { 
                characterDiv = document.getElementById("enemy-infor");
            } else {
                characterDiv = document.getElementById("member-infor");
            }

            // 創建欄位
            characterDiv.innerHTML = `
                <div id="${character.id}" class="item background">
                    <!-- 名稱、HP、MP -->
                    <div class="column-container bottomborder">
                        <div class="weapon-icon">${weaponIcon}</div>
                        <h4 class="column">
                            ${character.adj ? `${character.adj}` : ""}${character.name}
                        </h4>
                        <h4 class="column column-container">
                            <div class="column center">
                                <h4 class="mp">
                                    ${character.MaxMP > 0 ? `${character.MP} / ${character.MaxMP}` : "" }
                                </h4>
                            </div>
                            <div class="column center">
                                <h4 class="hp">
                                    ${character.tempHP ? `${character.tempHP}<br>` : "" }
                                    ${character.HP} / ${character.MaxHP}
                                </h4>
                            </div>
                        </h4>
                    </div>

                    <!-- 狀態、訊息 -->
                    <p id="${character.id}-status"></p>
                    <p id="${character.id}-action" class="battle-text">${message}</p>
                    <p id="team-action" class="battle-text"></p>

                    <div id="${character.id}-btn">
                        <!-- 行動選單 -->
                        <div id="row-1" class="action-buttons"></div>
                        <div id="row-2" class="action-buttons"></div>
                        <div id="row-3" class="action-buttons hide"></div>

                        <!-- 目標按鈕 -->
                        <div id="target-menu" class="row-buttons"></div>
                    </div>

                </div>
            `;

            // 顯示狀態
            const statusList = document.getElementById(`${character.id}-status`);
            statusList.innerHTML = "";
            character.status.forEach(status => {
                // 定義說明文字
                const infor = `【${status.name}】${status.description}${status.duration ? `（剩餘回合：${status.duration}）` : "" }`;

                // 創建狀態圖示，點擊時彈出說明文字
                const statusDiv = document.createElement("span");
                statusDiv.innerHTML = `
                    <button onclick="alert('${infor}')" class="status-button">${status.icon}</button>
                `;
                statusList.appendChild(statusDiv);
            });

            // 開始監聽點擊
            document.addEventListener("click", clickOutsideInfor);

            // 定義動作按鈕
            const actions = [
                // 目標相關
                { icon: "𖣓", text: "決定目標", type: "target", condition: () => isTargetable, function: () => selectTarget(character.id) },
                { icon: "×", text: "取消動作", type: "target", condition: () => character.id === selectedUser, function: () => deselectAttacker(character) },

                // 第一列
                { icon: "⚔️", text: "攻擊", row: 1, condition: () => isAvailable, function: () => selectAttacker(character.id, 'attack') },
                { icon: "💬", text: "交談", row: 1, condition: () => isAvailable, function: () => selectAttacker(character.id, 'talk') },
                { icon: "🏃", text: "逃跑", row: 1, condition: () => isAvailable, function: () => useSkill("escape", character.id, null) },

                // 第二列               
                { icon: "⚔️", text: "聯手攻擊", row: 2, condition: () => isAvailable && availableMembers.length >= 2, function: () => selectAttacker('team', 'attack') },
                { icon: "💰", text: "物品", row: 2, condition: () => isAvailable, function: () => useItem(character.id) },
                { icon: "🏃", text: "一起逃跑", row: 2, condition: () => isAvailable && availableMembers.length >= 2, function: () => teamAction("escape", null) },
            ];

            // 檢查是否可行動
            const availableMembers = JSON.parse(localStorage.getItem("availableMembers")) || [];
            let isAvailable = 
                availableMembers.some(m => m.id === character.id) && // 本回合還沒行動過
                !isTrue("敵人回合") && // 不是敵人回合中
                !hasStatus(character, "noAction"); // 沒有無法行動的狀態

            // 檢查是否可當成目標
            let isTargetable = false;
            if (selectedAction && selectedUser) {
                const skill = skillData.find(s => s.id === selectedAction); // 找到技能資料
                const user = availableMembers.find(m => m.id === selectedUser); // 找到使用者資料

                const frontMembers = JSON.parse(localStorage.getItem("frontMembers")) || [];
                const isFront = frontMembers.some(m => m.id === character.id); // 前排隊友

                const frontEnemies = JSON.parse(localStorage.getItem("frontEnemies")) || [];
                const isFrontEnemy = 
                    frontEnemies.some(m => m.id === character.id) || // 前排敵人
                    (frontEnemies.length === 0 && isEnemy); // 前排沒有敵人，將後排視為前排

                if (skill) {
                    isTargetable =
                        selectedUser === "team" && !availableMembers.some(m => m.weapon.category === "遠程") && isFrontEnemy || // 每個人都拿近戰武器，只能打前排
                        selectedUser === "team" && availableMembers.some(m => m.weapon.category === "遠程") && isEnemy || // 有人拿遠程武器，都可以打
                        skill.target === "依武器" && user && user.weapon.category !== "遠程" && isFrontEnemy || // 近戰武器只能打前排
                        skill.target === "依武器" && user && user.weapon.category === "遠程" && isEnemy || // 遠程武器都可以打
                        skill.target === "前排單體" && isFrontEnemy ||
                        skill.target === "後排單體" && isEnemy && !isFrontEnemy ||
                        skill.target === "同排單體" && frontMembers.some(m => m.id === selectedUser) && isFront ||
                        skill.target === "同排單體" && !frontMembers.some(m => m.id === selectedUser) && !isFront && !isEnemy ||
                        skill.target === "任一施法者" && character.MP > 0 ||
                        skill.target === "任一單體" ||
                        skill.target === "任一排";
                    isAvailable = false; // 選擇目標中，不顯示目標的動作按鈕
                }
            }

            // 創建目標按鈕、動作按紐
            const targetMenu = document.getElementById("target-menu");
            actions.forEach(action => {
                // 檢查條件
                if (action.condition && !action.condition()) return;

                // 創建按鈕
                const button = document.createElement("button");
                button.innerHTML = `
                    <span class="action-icon">${action.icon}</span>
                    <span class="small">${action.text}</span>
                `;
                button.addEventListener("click", action.function);

                // 判斷顯示位置
                if (action.row) {
                    document.getElementById("row-" + action.row).appendChild(button);
                } else if (action.type === "target") {
                    targetMenu.appendChild(button); // 目標
                }
            });

            // 敵人、無法行動者不顯示技能
            if (isEnemy || !isAvailable) return; 

            // 找到職業技能
            const skillIds = classData.find(cla => cla.id === character.classId).skills;

            // 創建技能按鈕
            const skillsMenu = document.getElementById("row-3");
            skillsMenu.innerHTML = "";
            skillIds.forEach(skillId => {
                // 找到技能資料
                const skill = skillData.find(s => s.id === skillId); 

	            // 檢查條件
                const disable =
                    (skill.condition && !evalCondition(skill.condition, character)) || // 不符合技能使用條件
                    (skill.cost > 0 && character.MP < skill.cost) || // MP 不足
                    (skill.cost > 0 && hasStatus(character, "noMagic")); // 被禁用法術

                // 創建按鈕
                const button = document.createElement("button");
	            if (!disable) { // 可用
                    button.innerHTML = `
                        <span class="action-icon">${skill.icon}</span>
                        <span class="small">${skill.name}</span>
                    `;
                    // 按下按鈕
                    button.addEventListener("click", () => {
                        console.log("使用技能：", skill);
                        if (skill.target === "自己") {
                            useSkill(skill.id, character.id, character.id); // 對自己使用
                        } else {
                            selectAttacker(character.id, skill.id); // 選擇目標
                        }
                    });
	            } else { // 不可用（灰字）
                    button.innerHTML = `
                        <div class="disable">
                            <span class="action-icon">${skill.icon}</span>
                            <span class="small">${skill.name}</span>
                        </div>
                    `;
                }
                skillsMenu.appendChild(button);
            });
        }

        // 點擊外部清除欄位
        function clickOutsideInfor() {
            // 檢查是否點擊在 avatar 上
            const avatars = document.querySelectorAll(".avatar");
            const clickAvatar = Array.from(avatars).some(avatar => avatar.contains(event.target));

            // 檢查是否點擊在按鈕上（尤其是結束回合按鈕）
            const buttons = document.querySelectorAll("button");
            const clickButton = Array.from(buttons).some(button => button.contains(event.target));

            // 檢查是否點擊在欄位上
            const memberInfor = document.getElementById("member-infor");
            const enemyInfor = document.getElementById("enemy-infor");
            const clickMemberInfor = memberInfor.contains(event.target);
            const clickEnemyInfor = enemyInfor.contains(event.target);
            memberInfor.addEventListener("click", e => e.stopPropagation());
            enemyInfor.addEventListener("click", e => e.stopPropagation());


            // 清除欄位
            if (!clickAvatar && !clickMemberInfor && !clickEnemyInfor && !clickButton) {
                memberInfor.innerHTML = "";
                enemyInfor.innerHTML = "";
                document.removeEventListener("click", clickOutsideInfor); // 停止監聽
                console.log("清除");
            }
        }

        // 顯示跳躍動畫
        function avatarJump(userId) {
            const jumper = document.getElementById(`${userId}-avatar`);
            if (!jumper) return;

            setTimeout(function() {
                jumper.classList.add("jump"); // 顯示彈跳動畫
            }, 1);
            setTimeout(function() {
                jumper.classList.remove("jump"); // 移除彈跳動畫
            }, 150);
        }

        // 檢查是否擁有狀態（可輸入狀態 id 或狀態的某個屬性）
        function hasStatus(character, key) {
            return character.status.some(sta => sta.key);
        }

    // === 技能邏輯區 ===

        let selectedUser = null; // 使用者
        let selectedAction = null; // 動作

        // 選擇使用者
        function selectAttacker(userId, actionId) {
            selectedUser = userId;
            selectedAction = actionId;
            document.getElementById("team-note").textContent = ""; // 清除提示
            document.getElementById("enemy-infor").innerHTML = ""; // 清空敵人欄位
            document.getElementById("member-infor").innerHTML = ""; // 清空我方欄位
            document.getElementById("title").textContent = texts.noTarget; // 顯示提示
        }

        // 取消使用者
        function deselectAttacker(user) {
            selectedUser = null;
            selectedAction = null;
            document.getElementById("title").textContent = ""; // 清除提示
            showInfor(user);
        }

        // 選擇目標
        function selectTarget(targetId) {
            if (selectedUser) {
                document.getElementById("enemy-note").textContent = ""; // 清除提示
                //localStorage.removeItem(`${targetId}-action-text`); // 清除目標的訊息

                // 處理動作
                if (selectedUser === "team" && selectedAction === "attack") {
                    teamAction("attack", targetId); // 聯手攻擊
                } else if (selectedAction === "talk") {
                    talk(targetId); // 交談
                } else {
                    useSkill(selectedAction, selectedUser, targetId); // 使用技能
                }

                // 重置
                selectedUser = null;
                selectedAction = null;
            }
        }

        // 使用技能（可輸入隊伍總敏捷）
        function useSkill(skillId, userId, targetId, teamDex) {
            // 找到技能資料
            const skill = skillData.find(s => s.id === skillId);

            // 讀取資料
            const presentMembers = JSON.parse(localStorage.getItem("presentMembers")) || [];
            let teamMembers = JSON.parse(localStorage.getItem("teamMembers")) || [];
            let enemies = JSON.parse(localStorage.getItem("enemies")) || [];

            let allCharacters = [...teamMembers, ...enemies];
            let user = allCharacters.find(m => m.id === userId);
            let target = allCharacters.find(m => m.id === targetId);

            const isEnemy = user.id.startsWith("enemy"); // 使用者是敵人

            removeAvailableMembers(user.id); // 使用者移出可行動成員

            // 如果未指定目標
            if (!target) {
                if (skill.target.startsWith("最高")) {
                    // 取得最高屬性
                    const attr = skill.target.replace("最高", "");

                    // 找到屬性值最高的角色
                    let maxValue = -Infinity; // 初始值為負無限大
                    allCharacters.forEach(character => {
                        // 如果敵人使用，目標需是上場成員
                        if (isEnemy && !presentMembers.some(m => m.id === character.id)) return;
                        // 如果我方使用，目標需是敵人
                        if (!isEnemy && !enemies.some(m => m.id === character.id)) return;

                        // 比較屬性值
                        if (character[attr].total > maxValue) { // 如果找到更高的屬性值，將陣列設為該角色
                            maxValue = character[attr].total; // 更新最高屬性值
                            maxCharacters = [character];
                        } else if (character[attr].total === maxValue) {
                            maxCharacters.push(character); // 如果屬性值相同，將該角色加入陣列
                        }
                    });

                    // 從屬性最高者中隨機選一個當目標
                    const randomIndex = Math.floor(Math.random() * maxCharacters.length);
                    target = maxCharacters[randomIndex];
                }
            }
            const targetIsEnemy = target.id.startsWith("enemy"); // 目標是敵人

            // 技能結果初始化
	        const result = {
                skill: skill,
		        hit: true,
		        damage: 0,
		        userDamage: 0,
		        crit: false,
		        targetStatus: [],
		        userStatus: [],
                mpAbsorb: 0,
                armorBreak: 0,
                escape: false,
	        };

	        // MP消耗
	        user.MP -= skill.cost || 0;

	        // 處理自動成功的情況
	        const autoHit = 
		        parseInt(localStorage.getItem("situation")) === 4 || // 偷襲回合
		        target.type.includes("植物") || // 植物類敵人
		        Object.values(target.status).some(s => s.immobile); // 目標無法行動

	        // 命中判定
	        if (skill.hitCheck && !autoHit) {
		        const [att, def] = skill.hitCheck.split("-vs-"); // 解析屬性
		        const rollResult = roll(teamDex || user[att].total, target[def].total); // 擲骰（如有指定 teamDex 就使用）
		        result.hit = rollResult.success;
		        result.chance = rollResult.chance;
		        console.log(`使用者: ${user.name}, 使用者 ${att}: ${user[att].total}, 目標: ${target.name}, 目標 ${def}: ${target[def].total}, 命中率: ${(result.chance * 100).toFixed(1)}%`);
		        
                // 未命中，直接顯示結果
                if (!result.hit) {
                    localStorage.setItem("teamMembers", JSON.stringify(teamMembers));
                    localStorage.setItem("enemies", JSON.stringify(enemies));
                    //localStorage.setItem("skillResult", JSON.stringify(result));

                    endAction(); // 行動結束
	                showSkillResult(result, user, target); // 顯示結果
                    return result; // 中斷函式，順便回傳給 teamAction()
                }
	        }

            // 爆擊判定
            if (result.hit) {
                if (skill.critRate && skill.critRate.includes("vs")) {
                    // 骰屬性
		            const [att, def] = skill.critRate.split("-vs-"); // 解析屬性
		            const rollResult = roll(user[att].total, target[def].total); // 擲骰
		            result.crit = rollResult.success;
                } else {
                    // 骰 D20
                    rollD20 = Math.floor(Math.random() * 20) + 1;
                    result.crit = rollD20 <= (skill.critRate || user.crit);
                }
            }

	        // 目標傷害（或治療）
	        if (skill.damage) {
		        result.damage = evalFormula(skill.damage, user, target); // 代入傷害公式
                if (result.crit) result.damage * 2; // 爆擊時傷害加倍

                if (result.damage > 0) {
                    // 傷害
                    target.tempHP = target.tempHP || 0; // 確保臨時生命值有值
                    const realDamage = result.damage - target.tempHP; // 計算實際傷害（減掉臨時生命值）

                    target.tempHP = Math.max(target.tempHP - result.damage, 0); // 扣除臨時生命值，不會低於 0
		            target.HP = Math.min(Math.max(target.HP - realDamage, 0), target.MaxHP); // 扣除 HP，不會低於 0 或高於最大值
		            console.log(`${user.name}擊中了${target.name}(${result.damage})！`);
                } else {
                    // 治療
		            target.HP = Math.min(Math.max(target.HP - result.damage, 0), target.MaxHP); // 扣除 HP，不會低於 0 或高於最大值
		            console.log(`${user.name}治療了${target.name}(${result.damage})！`);
                }
	        }

	        // 自身傷害（如反彈）
	        if (skill.userDamage) {
		        result.userDamage = evalFormula(skill.userDamage, user, target); // 代入傷害公式
                if (result.crit) result.userDamage * 2; // 爆擊時傷害加倍

                user.tempHP = user.tempHP || 0; // 確保臨時生命值有值
                const realDamage = result.userDamage - user.tempHP; // 計算實際傷害（減掉臨時生命值）

                user.tempHP = Math.max(user.tempHP - result.userDamage, 0); // 扣除臨時生命值，不會低於 0
		        user.HP = Math.min(Math.max(user.HP - realDamage, 0), user.MaxHP); // 扣除 HP，不會低於 0 或高於最大值
		        console.log(`${user.name}也受傷了(${result.userDamage})！`);
	        }

	        // 目標狀態
	        if (skill.targetStatus) {
                let addStatus = true; // 預設會處理狀態
                
                // 如需過檢定
                if (skill.statusCheck) { 
		            const [att, def] = skill.statusCheck.split("-vs-"); // 解析屬性
		            const rollResult = roll(user[att].total, target[def].total); // 擲骰
		            if (!rollResult.success) addStatus = false; // 失敗不添加狀態
                }

                // 處理每一個狀態
                if (addStatus) {
		            const statusIds = Array.isArray(skill.targetStatus) ? skill.targetStatus : [skill.targetStatus]; // 包成陣列
                    statusIds.forEach(statusId => {
                        const status = statusData.find(s => s.id === statusId.replace("-", "")); // 找到狀態資料

                        if (statusId.startsWith("-")) { 
                            // 移除狀態
                            target.status.filter(s => s.id !== status.id);
                            console.log(`${target.name}不再${status.name}了！`);
                        } else { 
                            // 添加狀態
		                    target.status.push(status);
		                    result.targetStatus.push(status);
		                    console.log(`${target.name}${status.name}了！`);
                        }
                    });
                }
	        }

	        // 自身狀態
	        if (skill.userStatus) {
                // 處理每一個狀態
		        const statusIds = Array.isArray(skill.userStatus) ? skill.userStatus : [skill.userStatus]; // 包成陣列
                statusIds.forEach(statusId => {
                    const status = statusData.find(s => s.id === statusId.replace("-", "")); // 找到狀態資料

                    if (statusId.startsWith("-")) { 
                        // 移除狀態
                        user.status.filter(s => s.id !== status.id);
                        console.log(`${user.name}不再${status.name}了！`);
                    } else { 
                        // 添加狀態
		                user.status.push(status);
		                result.userStatus.push(status);
		                console.log(`${user.name}${status.name}了！`);
                    }
                });
	        }

	        // MP 吸收
	        if (skill.mpAbsorb) {
                const realMpAbsorb = Math.min(skill.mpAbsorb, target.MP); // 計算實際傷害（不會超過目標 MP）
		        target.MP = Math.min(Math.max(target.MP - realMpAbsorb, 0), target.MaxMP); // 扣除 MP，不會低於 0 或高於最大值
                user.MP = Math.min(Math.max(user.MP + realMpAbsorb, 0), user.MaxMP); // 獲得 MP，不會低於 0 或高於最大值
                result.mpAbsorb = realMpAbsorb;
		        console.log(`${user.name}從${target.name}身上吸取 ${realMpAbsorb} MP。`);
	        }

	        //if (skill.mpDamage) {
            //    const realMpDamage = Math.min(skill.mpDamage, target.MP); // 計算實際傷害（不會超過目標 MP）
		    //    target.MP = Math.min(Math.max(target.MP - realMpDamage, 0), target.MaxMP); // 扣除 MP，不會低於 0 或高於最大值
		    //    console.log(`${target.name} 損失 ${realMpDamage} MP。`);
	        //}
	        //if (skill.userMpDamage) {
		    //    user.MP = Math.min(Math.max(user.MP - skill.userMpDamage, 0), user.MaxMP); // 扣除 MP，不會低於 0 或高於最大值
		    //    console.log(`${user.name} 回復 ${-skill.userMpDamage} MP。`);
	        //}

            // 給予臨時生命值
            if (skill.tempHP) {
		        addTempHP = evalFormula(skill.tempHP, user, target); // 代入傷害公式
                target.tempHP = (target.tempHP || 0) + addTempHP;
            }

            // 破甲
            if (skill.armorBreak) {
                const armLost = evalFormula(skill.armorBreak, user, target); // 代入傷害公式

                target.arm.armor = target.arm.armor || 0; // 確保裝備護甲有值
                const realLost = Math.min(armLost, target.arm.armor); // 計算實際傷害（不會超過裝備護甲值）

                target.arm.armor = target.arm.armor - realLost; // 扣除裝備護甲
                target.arm.total = target.arm.total - realLost; // 扣除總護甲
                target.armor.arm = target.arm.armor; // 同步更新裝備數據
                result.armorBreak = realLost;
            }

            // 逃跑
            if (skill.escape) {
                if (isEnemy) { // 敵人
                    enemies = enemies.filter(e => e.id === user.id);
                } else { // 隊友
                    removePresentMembers(user.id); // 移出上場成員
                    addEscapeMember(user.id); // 加入逃跑成員
                }
                result.escape = true;
            }

            // 儲存
            localStorage.setItem("teamMembers", JSON.stringify(teamMembers));
            localStorage.setItem("enemies", JSON.stringify(enemies));
            //localStorage.setItem("skillResult", JSON.stringify(result));

            endAction(); // 行動結束
	        showSkillResult(result, user, target); // 顯示結果
            return result; // 回傳給 teamAction()
        }

        // 聯手行動
        function teamAction(skillId, targetId) {
            // 找到敵人資料
            let enemies = JSON.parse(localStorage.getItem("enemies")) || [];
            let target = enemies.find(e => e.id === targetId);

            // 取得可行動成員的資料
		    const availableMembers = JSON.parse(localStorage.getItem("availableMembers")) || [];
            const teamDex = availableMembers.reduce((sum, member) => sum + member.dex.total, 0);

            // 備份資料
            const backupPresentMembers = JSON.parse(localStorage.getItem("presentMembers")) || [];
            const backupEscapeMember = JSON.parse(localStorage.getItem("escapeMember")) || [];

            const teamActions = {
                "attack": {
                    startMessage: "你們包圍目標，同時進攻",
                    action: (member) => useSkill('attack', member.id, targetId, teamDex),
                },
                "escape": {
                    startMessage: "你們保持陣形，避免分散",
                    failMessage: "你們沒有丟下夥伴，回來繼續面對敵人",
                    action: (member) => useSkill('escape', member.id, targetId),
                    //skip: (result) => result.hit, // 不顯示成功的訊息
                },
            };

            let message = teamActions[skillId].startMessage; // 訊息開頭

            // 每人行動一次
            let allHit = true;
            availableMembers.forEach(member => {
		        const result = teamActions[skillId].action(member); // 行動
                console.log(result.hit);
                //if (teamActions[skillId].skip(result)) return; // 跳過訊息
                message += `<br>` + member.name + localStorage.getItem(`${member.id}-action-text`); // 讀取結果並合併
                if (!result.hit) allHit = false; // 檢查是否全員成功
	        });

            // 處理逃跑失敗
            if (skillId === "escape" && !allHit) {
                message += `<br>` + teamActions[skillId].failMessage; // 添加失敗訊息

                // 還原逃跑者
                localStorage.setItem("presentMembers", JSON.stringify(backupPresentMembers));
                localStorage.setItem("escapeMember", JSON.stringify(backupEscapeMember));
                generateAvatar();
            }

            // 取得可行動成員的資料
		    //const availableMembers = JSON.parse(localStorage.getItem("availableMembers")) || [];
            //const teamDex = availableMembers.reduce((sum, member) => sum + member.dex.total, 0);

            // 每人行動一次
            //let message = "你們包圍目標，一起上！";
            //availableMembers.forEach(member => {
		    //    useSkill("attack", member.id, targetId, teamDex); // 用總敏捷擲骰
            //    message += `<br>` + member.name + localStorage.getItem(`${member.id}-action-text`); // 讀取結果並合併
	        //});


            // 用第一位成員的欄位顯示結果
            showInfor(availableMembers[0]);
            document.getElementById(`${availableMembers[0].id}-btn`).innerHTML = ""; // 清除按鈕
            document.getElementById(`${availableMembers[0].id}-action`).innerHTML = message; // 顯示合併的訊息
        }

        // 計算傷害公式
        function evalFormula(formula, user, target) {
            // 自動補上 .total
            formula = formula.replace(
                /\b(user|target)\.(str|dex|con|int|wis|cha|arm)\b/g,
                "$&.total"
            );

            // 計算結果
            let result = Function("user", "target", `return ${formula};`)(user, target);

            // 最小為 0（治癒除外）
            if (!formula.startsWith("-")) result = Math.max(result, 0);

            return result;
        }

        // 檢查技能使用條件
        function evalCondition(formula, user) {
	        // 自動補上 .total
	        const preprocessed = formula.replace(
		        /\b(user)\.(str|dex|con|int|wis|cha|arm)\b/g,
		        "$&.total"
	        );

            // 讀取資料
            const situation = parseInt(localStorage.getItem("situation"));

            // 回傳計算結果
            return Function("user", "situation", `return ${preprocessed};`)(user, situation);
        }

        // 顯示技能結果
        function showSkillResult(result, user, target) {
            // 顯示使用者跳躍動畫
            avatarJump(user.id);

            // 清除雙方欄位
            document.getElementById("enemy-infor").innerHTML = "";
            document.getElementById("member-infor").innerHTML = "";

            // 清除目標的舊訊息
            localStorage.removeItem(`${target.id}-action-text`);

            // 顯示使用者欄位，清除按紐
            showInfor(user);
            document.getElementById(`${user.id}-btn`).innerHTML = "";

            const skill = result.skill;
            //const user = result.user;
            //const target = result.target;

            // 合併形容詞和名稱
            if (target.adj) target.name = target.adj + target.name;

            // 判斷訊息顯示位置
            let logBox = document.getElementById(`${user.id}-action`);

            // 顯示命中結果
            if (result.hit) {
                logBox.innerText = skill.hitMessage // 命中
                .replace("${target.name}", target.name)
                .replace("${result.damage}", result.damage > 0 ? result.damage : -result.damage) // 負數（治療）顯示為正數
                .replace("${result.mpAbsorb}", result.mpAbsorb)
                .replace("${result.armorBreak}", result.armorBreak)
                .replace("${result.userDamage}", result.userDamage);
            } else {
                logBox.innerText = skill.missMessage // 未命中
                .replace("${target.name}", target.name);
                localStorage.setItem(`${user.id}-action-text`, logBox.innerText);
            }

            // 顯示爆擊結果
            if (result.crit) {
                logBox.innerText += "造成爆擊！";
            }

            // 顯示目標狀態
            if (result.targetStatus.length > 0) {
                if (target.id !== user.id) { // 確保目標不是使用者本人
                    // 處理每個有訊息的狀態
                    result.targetStatus.forEach(status => {                        
                        if (status.getMessage) {
                            // 顯示獲得狀態的訊息（在使用者的欄位）
                            logBox.innerText += target.name + status.getMessage;

                            // 儲存獲得狀態的訊息（在目標的欄位，點擊才會看到）
                            localStorage.setItem(`${target.id}-action-text`, status.getMessage);
                        }
                    });
                }
            }

            // 受傷的 HP 變紅
            if (result.damage > 0) {
                const redHP = document.getElementById(`${target.id}-HP`);
                if (redHP) redHP.classList.add("red-hp");
            }
            if (result.userDamage > 0) {
                const redHP = document.getElementById(`${user.id}-HP`);
                if (redHP) redHP.classList.add("red-hp");
            }

            // 儲存訊息
            localStorage.setItem(`${user.id}-action-text`, logBox.innerText);
        }

    // === 回合邏輯區 ===

        // 攻擊邏輯
        function fightX(attacker, targetId) {
            // 獲取敵人資料
            let enemies = JSON.parse(localStorage.getItem("enemies")) || [];
            let target = enemies.find(e => e.id === targetId);
            let enemyName = target.adj + target.name;

            // 讀取可行動成員的資料
            let availableMembers = JSON.parse(localStorage.getItem("availableMembers")) || [];
          
            // 確認攻擊者人數
            if (attacker === "team") {
                // 聯手攻擊，計入所有可行動成員
                attacker = availableMembers;
            } else {
                // 單獨攻擊，找到攻擊者
                attacker = [attacker]; // 包成陣列
            }

            // 如果敵人飛行中，只計入有遠程武器的成員
            let isFly = Object.values(target.status).some(s => s.name === "飛行");
            if (isFly) {
                attacker = attacker.filter(member => member.weapon && member.weapon.category === "遠程");
            }

            // 取得攻擊者資料
            let attackerName = [], attackerDex = 0, attackerStr = 0, attackerWeapon = [];
            let jumpers = [];
            attacker.forEach(member => {
                attackerName.push(member.name);
                attackerDex += member.dex.total; // 我方總敏捷
                attackerStr += member.str.total; // 我方總力量
                attackerWeapon.push(member.weapon); // 我方武器
                jumpers.push(`${member.id}-avatar`); // 添加彈跳動畫
            });
            localStorage.setItem("jumpers", JSON.stringify(jumpers));

            // 以雙方敏捷擲骰
            let result = roll(attackerDex, target.dex.total);

            // 檢查是否有例外
            let situation = parseInt(localStorage.getItem("situation"));
            let isPlant = target.type.includes("植物");
            let isProne = Object.values(target.status).some(s => s.name === "倒地");

            if (situation === 4 || isProne || isPlant) { 
                // 如果敵人無防備、目標倒地、目標是植物，自動成功
                result = { success: true, chance: 1 };
            }
            console.log(`攻擊者: ${attackerName}, 敏捷: ${attackerDex}, 目標: ${targetId}, 目標敏捷: ${target.dex.total}`);
            console.log(`攻擊命中率: ${(result.chance*100).toFixed(2)}%`);  // 顯示精確到小數點後2位

            // 攻擊結果
            if (result.success === true) {
                // 攻擊成功，對目標造成傷害
                let damage = Math.max(attackerStr - target.arm.total, 0); // 傷害 = 我方力量總和 - 敵人護甲
                target.HP = Math.max(target.HP - damage, 0); // HP 減少，不會低於0

                // 檢查敵人是否死亡
                if (target.HP <= 0) {
                    // 敵人死亡
                    if (attackerId === "team") {
                        // 顯示聯手擊殺訊息（在隊伍的欄位）
                        document.getElementById("team-action").textContent = texts.teamKillEnemy(enemyName, damage);

                        // 雷納德添加情緒
                        if (isCompanion("雷納德")) getEmotion("雷納德", "teamwork");

                    } else {
                        // 顯示單獨擊殺訊息（在攻擊者的欄位）
                        localStorage.setItem(`${attackerId}-action-text`, texts.killEnemy(enemyName, damage));
                        showInfor(singleAttacker);

                        // 塔爾穆克添加情緒
                        if (singleAttacker.name === "塔爾穆克") getEmotion("塔爾穆克", "kill");
                    }
                    // 清除目標
                    localStorage.removeItem("selectedTarget");

                } else {
                    // 敵人活著，更新顯示 HP
                    document.getElementById(`${targetId}-HP`).textContent = target.HP;

                    // HP 變為紅字（只有一個）
                    let redHP = [];
                    redHP.push(`${targetId}-HP`);
                    localStorage.setItem("redHP", JSON.stringify(redHP));

                    if (attackerId === "team") {
                        // 顯示聯手攻擊成功訊息（在隊伍的欄位）
                        localStorage.setItem(`${attackerId}-action-text`, texts.teamFightWin(enemyName, damage));

                    } else {
                        // 顯示單獨攻擊成功訊息（在攻擊者的欄位）
                        localStorage.setItem(`${attackerId}-action-text`, texts.fightWin(enemyName, damage));
                        showInfor(singleAttacker);
                    }

                    // 附加狀態
                    attackerWeapon.forEach(weapon => {
                        let statusName = giveStatus(weapon, target);
                        if (statusName) {
                            // 顯示附加的訊息
                            localStorage.setItem(`${attackerId}-action-text`, texts.fightWinWithStatus(enemyName, damage, statusName));
                            showInfor(singleAttacker);
                            console.log("造成" + statusName);
                        };
                    });
                };

                localStorage.setItem("enemies", JSON.stringify(enemies));  // 儲存更新後的敵人資料

            } else {
                // 攻擊失敗

                if (isFly && attackerDex === 0) {
                    // 如果失敗是因為目標在飛行，且沒有遠程武器
                    if (attackerId === "team") {
                        // 顯示聯手攻擊無法觸及訊息（在隊伍的欄位）
                        document.getElementById("team-action").textContent = texts.fightFlyingEnemy(enemyName);
                    } else {
                        // 顯示單獨攻擊無法觸及訊息（在攻擊者的欄位）
                        localStorage.setItem(`${attackerId}-action-text`, texts.fightFlyingEnemy(enemyName));
                        showInfor(singleAttacker);
                    }
                    
                } else {
                    // 預設情況
                    if (attackerId === "team") {
                        // 顯示聯手攻擊失敗訊息（在隊伍的欄位）
                        document.getElementById("team-action").textContent = texts.teamFightLose(enemyName);
                    } else {
                        // 顯示單獨攻擊失敗訊息（在攻擊者的欄位）
                        localStorage.setItem(`${attackerId}-action-text`, texts.fightLose(enemyName));
                        showInfor(singleAttacker);
                    }
                }
            }

            // 攻擊結束後
            if (attackerId === "team") {
                // 聯手攻擊，隱藏可行動成員的攻擊、逃跑按鈕
                availableMembers.forEach(member => {
                    document.getElementById(`${member.id}-btn`).forEach(button => {
                        button.style.display = "none";
                    });

                    removeAvailableMembers(member.id); // 將攻擊者移出可行動成員
                });

                // 隱藏聯手攻擊、一起逃跑按鈕
                document.getElementById("team-btn").style.display = "none";
            } else {
                // 單獨攻擊，隱藏攻擊者的攻擊、逃跑按鈕
                document.getElementById(`${attackerId}-btn`).forEach(button => {
                    button.style.display = "none";
                });

                removeAvailableMembers(attackerId); // 將攻擊者移出可行動成員
            }

            // 清除敵人的欄位
            localStorage.removeItem(`${targetId}-action-text`);
            document.getElementById("enemy-infor").innerHTML = "";

            endAction();
        }

        // 逃跑邏輯
        function escapeX(escaperId) {
            let presentMembers = JSON.parse(localStorage.getItem("presentMembers")) || [];
            let availableMembers = JSON.parse(localStorage.getItem("availableMembers")) || [];

            let escaperName;
            let escaperDex = 0; // 我方總敏捷
            let minDexMembers = [];
          
            if (escaperId === "team") {
                // 一起逃跑，找到 dex 最低的成員資料
                let minDex = Infinity; // 設定初始值為無限大
                availableMembers.forEach(member => {
                    if (member.dex.total < minDex) { // 如果找到更低的 dex，重置陣列，將該角色加入陣列
                        minDex = member.dex.total; // 更新最低 dex
                        minDexMembers = [member];
                    } else if (member.dex.total === minDex) {
                        minDexMembers.push(member); // 如果dex相同，將該角色加入陣列
                    }
                });
                escaperName = "一起";
                escaperDex = minDex;
            } else {
                // 單獨逃跑，找到逃跑者的資料
                singleEscaper = availableMembers.find(comp => comp.id === escaperId);
                escaperName = singleEscaper.name;
                escaperDex = singleEscaper.dex.total;
            }

            // 讀取第一個敵人的資料
            let enemies = JSON.parse(localStorage.getItem("enemies")) || [];
            let enemyDex = enemies.length > 0 ? enemies[0].dex.total : 0; // 取第一個敵人的敏捷
            let enemyType = enemies.length > 0 ? enemies[0].type : ""; // 取第一個敵人的類型
            let availableEnemies = JSON.parse(localStorage.getItem("availableEnemies")) || [];

            // 以雙方敏捷擲骰
            let result = roll(escaperDex, enemyDex);

            // 檢查是否有例外
            let situation = parseInt(localStorage.getItem("situation"));
            let isPlant = enemyType.includes("植物");
            let AllProne = enemies.filter(s => !s.status.some(s => s.name === "倒地")).length === 0;

            if (situation === 4 || isPlant ||  AllProne) { 
                // 如果敵人無防備、敵人是植物、敵人全倒地，自動成功
                result = { success: true, chance: 1 };
            } else if (escaperId !== "team" && presentMembers.length > availableEnemies.length) {
                // 如果單獨逃跑時，上場成員比可行動敵人多，敵人就無法分心追趕，自動成功
                result = { success: true, chance: 1 };
            }
            console.log(`逃跑者: ${escaperName}, 敏捷: ${escaperDex}, 敵人敏捷: ${enemyDex}`);
            console.log(`逃跑成功率: ${(result.chance*100).toFixed(2)}%`);

            // 逃跑結果
            if (result.success === true) {
                // 逃跑成功
                if (escaperId === "team") {
                    availableMembers.forEach(member => {
                        removePresentMembers(member.id); // 移出上場成員
                        addEscapeMember(member.id); // 加入逃跑成員
                    });

                    // 取得所有逃跑成員的名字並用頓號「、」分隔
                    let escapers = availableMembers.map(member => member.name).join("、");

                    // 顯示一起逃跑成功訊息
                    document.getElementById("team-action").textContent = texts.teamEscapeSuccess(escapers);
                    document.getElementById("member-infor").innerHTML = ""; // 清除欄位

                } else {
                    removePresentMembers(escaperId); // 移出上場成員
                    addEscapeMember(escaperId); // 加入逃跑成員

                    // 顯示單獨逃跑成功訊息（在逃跑者的欄位）
                    localStorage.setItem(`${escaperId}-action-text`, texts.escapeSuccess);
                    showInfor(singleEscaper);

                }

            } else {
                // 逃跑失敗
                if (escaperId === "team") {
                    // 取得敏捷最低者的名字並用頓號「、」分隔
                    escapers = minDexMembers.map(member => member.name).join("、");

                    // 顯示一起逃跑失敗訊息
                    document.getElementById("team-action").textContent = texts.teamEscapeFail(escapers);
                    document.getElementById("member-infor").innerHTML = ""; // 清除欄位

                } else {
                    // 顯示單獨逃跑失敗訊息（在逃跑者的欄位）
                    //document.getElementById(`${escaperId}-action`).textContent = texts.escapeFail(escaperName);
                    localStorage.setItem(`${escaperId}-action-text`, texts.escapeFail);
                    showInfor(singleEscaper);
                }
            }

            // 逃跑結束後
            if (escaperId === "team") {
                // 一起逃跑，隱藏可行動成員的攻擊、逃跑按鈕
                availableMembers.forEach(member => {
                    document.getElementById(`${member.id}-btn`).forEach(button => {
                        button.style.display = "none";
                    });

                    removeAvailableMembers(member.id); // 將攻擊者移出可行動成員
                });

                // 隱藏聯手攻擊和一起逃跑按鈕
                document.getElementById("team-btn").style.display = "none";
            } else {
                // 單獨攻擊，隱藏逃跑者的攻擊、逃跑按鈕
                document.getElementById(`${escaperId}-btn`).forEach(button => {
                    button.style.display = "none";
                });

                removeAvailableMembers(escaperId); // 將逃跑者移出可行動成員
            }

            endAction();
        }

        // 使用物品
        function useItem(userId) {
            removeAvailableMembers(userId); // 移出可行動成員
            window.location.href = 'menu/inventory.html'; // 跳轉到物品頁面
        }

        // 走位
        function move(memberId) {
            // 讀取成員資料
            const presentMembers = JSON.parse(localStorage.getItem("presentMembers")) || [];
            const member = presentMembers.find(member => member.id === memberId);

            // 檢查成員是否在前排中
            let frontMembers = JSON.parse(localStorage.getItem("frontMembers")) || [];
            const isFront = frontMembers.some(member => member.id === memberId);
            console.log("前排成員：", frontMembers);

            if (isFront) {
                // 如果已在前排，從前排移除
                frontMembers = frontMembers.filter(m => m.id !== memberId);
            
            } else {
                // 否則，加到前排
                frontMembers.push(member);
            }

            localStorage.setItem("frontMembers", JSON.stringify(frontMembers));
            console.log("前排成員：", frontMembers);
            generateAvatar();
            //showInfor(member);
            avatarJump(memberId); // 跳躍動畫
        }

        // 交談
        function talk(targetId) {
            // 讀取所有敵人的資料
            let enemies = JSON.parse(localStorage.getItem("enemies")) || [];
            let enemyType = enemies.length > 0 ? enemies[0].type : ""; // 取第一個敵人的類型

            // 檢查敵人類型是不是智慧
            if (enemyType.includes("智慧")) {
                    // 如果已選擇目標，就進入交談
                    localStorage.setItem("npcId", targetId); // 儲存交談對象

                    // 隱藏主角的攻擊、逃跑按鈕
                    document.getElementById("player-btn").forEach(button => {
                        button.style.display = "none";
                    });
                    removeAvailableMembers("player"); // 將主角移出可行動成員
                    
                    window.location.href = 'battleTalk.html'; // 跳轉到交談頁面
            } else {
                // 如果不是智慧，就顯示無法對話的提示
                document.getElementById("enemy-note").textContent = texts.cannotTalk;
            }
        }

        // 敵人攻擊邏輯
        function enemyFightX() {
            // 讀取同伴資料
            let teamMembers = JSON.parse(localStorage.getItem("teamMembers"));
            let frontMembers = JSON.parse(localStorage.getItem("frontMembers")) || [];
            let presentMembers = JSON.parse(localStorage.getItem("presentMembers"));

            // 讀取第一個敵人的資料
            let enemies = JSON.parse(localStorage.getItem("enemies")) || [];
            let enemyType = enemies.length > 0 ? enemies[0].type : 0;
            let enemyDex = enemies[0].dex.total; 
            let enemyStr = enemies[0].str.total;

            // 讀取可行動敵人
            let availableEnemies = JSON.parse(localStorage.getItem("availableEnemies"))

            // 每個敵人行動
            enemies.forEach(enemy => {
                // 無法行動則中止
                let isAvailable = availableEnemies.some(e => e.id === enemy.id);
                if (!isAvailable) return;

                // 若上場成員沒人則中止（戰敗時讓玩家看情況）
                if (presentMembers.length === 0) return;

                // 添加彈跳動畫
                let jumpers = [];
                jumpers.push(`${enemy.id}-avatar`);
                localStorage.setItem("jumpers", JSON.stringify(jumpers));

                // 如果是飛行類敵人，有 20% 機率飛行
                if (enemyType.includes("飛行")) {
                    if (Math.random() <= 0.2) {
                        const fly = statusData.find(s => s.name === "飛行");
                        enemy.status.push(fly);
                        localStorage.setItem("enemies", JSON.stringify(enemies));

                        // 顯示飛行的訊息
                        localStorage.setItem(`${enemy.id}-action-text`, texts.enemyFly);
                        showInfor(enemy);
                        return;
                    }
                }

                // 從隨機選擇一個目標
                let hurtMember;
                if (frontMembers.length > 0) {
                    // 優先從前排選擇
                    const randomIndex = Math.floor(Math.random() * frontMembers.length);
                    hurtMember = teamMembers.find(m => m.id === frontMembers[randomIndex].id);
                } else { 
                    // 如果前排無人，從上場成員中選擇
                    const randomIndex = Math.floor(Math.random() * presentMembers.length);
                    hurtMember = teamMembers.find(m => m.id === presentMembers[randomIndex].id);
                }

                // 以雙方敏捷擲骰
                let result = roll(enemyDex, hurtMember.dex.total);

                // 檢查是否有例外
                let isProne = Object.values(hurtMember.status).some(s => s.name === "倒地");
                let situation = parseInt(localStorage.getItem("situation"));

                if (situation === 4 || isProne) { 
                    // 如果目標倒地，自動成功
                    result = { success: true, chance: 1 };
                }

                console.log(`攻擊者: ${enemy.name}, 敏捷: ${enemyDex}, 目標: ${hurtMember.name}, 目標敏捷: ${hurtMember.dex.total}`);
                console.log(`計算的敵人命中率: ${(result.chance*100).toFixed(2)}%`);  // 顯示精確到小數點後2位

                // 攻擊結果
                if (result.success === true) {
                    // 敵人攻擊成功，對角色造成傷害
                    let damage = Math.max(enemyStr - hurtMember.arm.total, 0); // 傷害 = 攻擊者的力量 - 目標的護甲
                    hurtMember.HP = Math.max(hurtMember.HP - damage, 0); // HP減少，不會低於0

                    // 更新顯示 HP
                    if (document.getElementById(`${hurtMember.id}-HP`)) {
                        document.getElementById(`${hurtMember.id}-HP`).textContent = hurtMember.HP;
                    }

                    // HP變為紅字（不移除之前的紅字，可以同時有多個紅字）
                    let redHP = JSON.parse(localStorage.getItem("redHP")) || [];
                    redHP.push(`${hurtMember.id}-HP`);
                    localStorage.setItem("redHP", JSON.stringify(redHP));

                    // 判斷角色是否死亡
                    if (hurtMember.HP <= 0) {
                        // 角色死亡，顯示被擊殺訊息（在敵人的欄位）
                        localStorage.setItem(`${enemy.id}-action-text`, texts.enemyKill(hurtMember.name, damage));

                    } else {
                        // 角色活著，顯示被攻擊訊息（在敵人的欄位）
                        localStorage.setItem(`${enemy.id}-action-text`, texts.enemyWin(hurtMember.name, damage));
                        
                        // 附加狀態（來自敵人的能力或武器）
                        let statusName;
                        if (enemy.addStatus) {
                            statusName = giveStatus(enemy, hurtMember);
                        } else {
                            statusName = giveStatus(enemy.weapon, hurtMember);
                        }

                        if (statusName) {
                            // 顯示附加的訊息（在敵人的欄位）
                            localStorage.setItem(`${enemy.id}-action-text`, texts.enemyWinWithStatus(hurtMember.name, damage, statusName));
                            console.log("造成" + statusName);
                        }
                    }
                    localStorage.setItem("teamMembers", JSON.stringify(teamMembers));

                } else {
                    // 敵人攻擊失敗，顯示訊息（在敵人的欄位）
                    localStorage.setItem(`${enemy.id}-action-text`, texts.enemyLose(hurtMember.name));
                }
                showInfor(enemy);
                endAction();
            })
        }

        // 角色離開可行動隊伍
        function removeAvailableMembers(memberId) {
            let availableMembers = JSON.parse(localStorage.getItem("availableMembers")) || [];
            let index = availableMembers.findIndex(member => member.id === memberId);

            if (index !== -1) {
                let removedMember = availableMembers.splice(index, 1)[0]; // 移除該成員
                //console.log(`${removedMember.name} 離開了隊伍`);
            } else {
                console.warn(`無效的同伴: ${memberId}`);
            }
            localStorage.setItem("availableMembers", JSON.stringify(availableMembers));
            //console.log("還沒行動過的成員：", availableMembers);
        }

        // 角色離開上場成員
        function removePresentMembers(memberId) {
            let presentMembers = JSON.parse(localStorage.getItem("presentMembers")) || [];
            let index = presentMembers.findIndex(member => member.id === memberId);

            if (index !== -1) {
                let removedMember = presentMembers.splice(index, 1)[0]; // 移除並返回該成員
                //console.log(`${removedMember.name} 離開了隊伍`);
            } else {
                console.warn(`無效的同伴: ${memberId}`);
            }
            localStorage.setItem("presentMembers", JSON.stringify(presentMembers));

            // 同步更新前排成員
            let frontMembers = JSON.parse(localStorage.getItem("frontMembers")) || [];
            frontMembers = frontMembers.filter(member => presentMembers.some(m => m.id === member.id)); // 篩選還在場的成員
            localStorage.setItem("frontMembers", JSON.stringify(frontMembers));
            //console.log("剩餘成員：", presentMembers);
        }

        // 角色加入逃跑成員
        function addEscapeMember(escaperId) {
            // 讀取目前已逃跑的成員
            let escapeMember = JSON.parse(localStorage.getItem("escapeMember")) || [];
            
            // 讀取可行動成員的資料
            let availableMembers = JSON.parse(localStorage.getItem("availableMembers")) || [];
            
            // 找到逃跑者的資料
            let member = availableMembers.find(comp => comp.id === escaperId);

            //加入逃跑成員
            escapeMember.push(member);

            localStorage.setItem("escapeMember", JSON.stringify(escapeMember));
            console.log("已逃跑成員：", escapeMember);
        }

        // 行動結束（敵我通用）
        function endAction() {  
            let battleResult = 0;
            let respawn = 0;

            // 讀取所有敵人資料
            let enemies = JSON.parse(localStorage.getItem("enemies")) || [];
            let frontEnemies = JSON.parse(localStorage.getItem("frontEnemies")) || [];

            // 檢查是否為敵人回合
            const endBtn = document.getElementById("end-btn"); // 結束回合按紐
            const nextBtn = document.getElementById("next-btn"); // 下一個敵人按紐
            if (isTrue("敵人回合")) {
                endBtn.style.display = "none";
                nextBtn.style.display = "block";
            } else {
                endBtn.style.display = "block";
                nextBtn.style.display = "none";
            }

            // 如果殺死守衛，通緝等級上升，名聲下降
            enemies.forEach(enemy => {
                if (enemy.name === "守衛" && enemy.HP === 0) {
                    addWantedLevel(5);
                    addPlayerFame(-5);
                }
            });

            // 計算獻祭的靈魂數量
            enemies.forEach(enemy => {
                if (enemy.HP === 0) {
                    let soulCount = parseInt(localStorage.getItem("soulCount"));
                    soulCount ++; // 靈魂增加
                    localStorage.setItem("soulCount", soulCount);
                }
            });

            // 檢查是否執行惡魔攻擊
            const demonAttack = localStorage.getItem("demonAttack");
            if (demonAttack) {
                enemies.forEach(enemy => {
                    let damage = 10; // 傷害 = 10
                    enemy.HP = Math.max(enemy.HP - damage, 0); // HP 減少，不會低於0

                    // HP變為紅字
                    //document.getElementById(`${enemy.id}-HP`).classList.add("red-hp");
                    let redHP = [];
                    redHP.push(`${enemy.id}-HP`);
                    localStorage.setItem("redHP", JSON.stringify(redHP));

                    // 顯示敵人燃燒的描述
                    //document.getElementById(`${enemy.id}-action`).textContent = texts.demonAttacked;
                    localStorage.setItem(`${enemy.id}-action-text`, texts.demonAttacked);
                });
                localStorage.setItem("enemies", JSON.stringify(enemies)); // 儲存更新後的敵人資料
                localStorage.removeItem("demonAttack"); // 清除惡魔攻擊
            }

            // 讀取成員資料
            const teamMembers = JSON.parse(localStorage.getItem("teamMembers")) || [];
            let presentMembers = JSON.parse(localStorage.getItem("presentMembers")) || [];
            let availableMembers = JSON.parse(localStorage.getItem("availableMembers")) || [];
            let frontMembers = JSON.parse(localStorage.getItem("frontMembers")) || [];
            let escapeMember = JSON.parse(localStorage.getItem("escapeMember")) || [];

            // 同步更新角色資料
            [presentMembers, availableMembers, frontMembers].forEach(array =>{
                array.forEach(member => {
                    let existingMember = teamMembers.find(m => m.id === member.id);
                    if (existingMember) {
                        member.HP = existingMember.HP; // HP
                        member.tempHP = existingMember.tempHP; // 臨時生命值
                        member.MP = existingMember.MP; // MP
                        member.status = existingMember.status; // 狀態
                    }
                });
            });

            // 根據角色 HP 更新情緒
            teamMembers.forEach(member => {
                if (member.HP === member.MaxHP) {
                    getEmotion(member.id, "fullHP");
                } else {
                    loseEmotion(member.id, "fullHP");
                }
            });

            // 檢查是否有角色死亡
            let deadMembers = presentMembers.filter(member => member.HP <= 0);
            if (deadMembers.length) {
                // 顯示死亡訊息（可顯示多人）
                let deadMemberNames = deadMembers.map(member => member.name).join("、");
                //document.getElementById("team-action").textContent = texts.die(deadMemberNames); // 顯示死亡訊息

                // 遍歷死亡角色，添加情緒
                deadMembers.forEach(member => {
                    getEmotion(member.id, "knockedDown");
                });

                // 如果主角死亡，雷納德添加情緒
                let playerDead = deadMembers.some(member => member.id === "player");
                if (playerDead && isCompanion("雷納德")) {
                    getEmotion("雷納德", "selfBlame");
                }
            }

            // 檢查角色是否非死即逃
            if (presentMembers.length > 0) { // 檢查上場成員是否有人（如果沒人，有可能是全員逃走）
                let allMembersDead = presentMembers.every(member => member.HP <= 0); // 檢查上場成員是否都死亡
                if (allMembersDead) {
                    if (escapeMember.length > 0) { // 檢查逃跑成員是否有人
                        // 有人死亡，剩下的人都已逃走
                        battleResult = 3;
                        localStorage.setItem("battleResult", battleResult);
                        return; // 防止繼續執行後面的邏輯
                    }
                }
            }

            // 移除死亡角色，只保留HP大於0的角色
            presentMembers = presentMembers.filter(member => member.HP > 0); 
            availableMembers = availableMembers.filter(member => member.HP > 0); 
            frontMembers = frontMembers.filter(member => member.HP > 0); 
            localStorage.setItem("presentMembers", JSON.stringify(presentMembers));
            localStorage.setItem("availableMembers", JSON.stringify(availableMembers));
            localStorage.setItem("frontMembers", JSON.stringify(frontMembers));
            localStorage.removeItem("deadMembers");
            
            //console.log("剩餘成員:", presentMembers);
            //console.log("可行動的成員", availableMembers);

            // 檢查隊伍是否全滅
            if (presentMembers.length === 0) { // 檢查上場成員是否 0 人
                if (escapeMember.length === 0) { // 檢查逃跑成員是否 0 人
                    // 全員死亡
                    generateAvatar(); // 更新顯示圖像
                    defeated();
                } else {
                    // 全員逃走
                    battleResult = 2;
                    localStorage.setItem("battleResult", battleResult);
                    localStorage.removeItem("inEvent"); // 清除事件
                    endBattle();
                }
                return; // 防止繼續執行後面的邏輯
            }

            // 檢查敵人是否全滅
            if (enemies.every(enemy => enemy.HP <= 0)) {
                // 戰鬥勝利
                loot();
                battleResult = 1;
                localStorage.setItem("battleResult", battleResult);
                turnSwitch(); // 如果有觸發開關，將開關打開

                // 如果有指定戰勝後的對話
                const encounter = JSON.parse(localStorage.getItem("encounter")) || [];
                if (encounter && encounter.successKey) {
                    localStorage.setItem("currentKey", encounter.successKey);
                }

                // 添加戰勝的情緒
                presentMembers.forEach(member => {
                    getEmotion(member.id, "battleWin");
                })

                endBattle();
            }

            // 檢查是否搶劫敵人
            let robEnemy = localStorage.getItem("robEnemy") === "true"; 
            if (robEnemy) {
                // 搶劫敵人
                loot();
                battleResult = 4;
                localStorage.setItem("battleResult", battleResult);
                endBattle();
            }

            // 檢查是否拒絕敵人投降
            if (isTrue("拒絕投降")) {
                turnSwitch("拒絕投降", false);
                newRound();
            }

            // 移除死亡的敵人
            enemies = enemies.filter(enemy => enemy.HP > 0); // 只保留HP大於0的敵人
            frontEnemies = frontEnemies.filter(enemy => enemies.some(e => e.id === enemy.id)); // 篩選還在場的敵人
            localStorage.setItem("enemies", JSON.stringify(enemies)); // 更新localStorage中的敵人資料
            localStorage.setItem("frontEnemies", JSON.stringify(frontEnemies)); // 更新localStorage中的敵人資料
            generateAvatar(); // 更新顯示圖像
        }

        // 我方回合結束
        function endRound() {
            let teamMembers = JSON.parse(localStorage.getItem("teamMembers")) || [];
            let presentMembers = JSON.parse(localStorage.getItem("presentMembers")) || [];

            // 移除選擇用的物件
            let selectedUser = null; // 使用者
            let selectedAction = null; // 動作
            document.getElementById("title").textContent = ""; // 提示
            document.getElementById("member-infor").innerHTML = ""; // 我方欄位

            // 移除戰鬥訊息
            document.querySelectorAll(".battle-text").forEach(el => el.textContent = "");
            teamMembers.forEach(member => {
                localStorage.removeItem(`${member.id}-action-text`);
            });

            // 移除HP的紅字
            for (const el of document.querySelectorAll(".red-hp")) el.classList.remove("red-hp");
            localStorage.removeItem("redHP");

            // 角色的狀態減少持續回合
            teamMembers.forEach(member => {    
                member.status.forEach(s => {
                    s.duration --; // 減少持續回合
                });

                // 移除已結束的狀態
                member.status = member.status.filter(s => s.duration > 0);
            });

            // 儲存更新後的資料
            localStorage.setItem("teamMembers", JSON.stringify(teamMembers));


            // 判斷是否已經戰敗（因為戰勝的話，會直接在行動結束時跳轉，戰敗的話，要先讓玩家看一下發生什麼事，然後按下「回合結束」後才跳轉）
            battleResult = localStorage.getItem("battleResult");
            if (battleResult && (battleResult !== 1 || battleResult !== 2 || battleResult !== 4)) {
                localStorage.removeItem("inEvent"); // 清除事件
                endBattle();
                return;
            }
            
            // 檢查俘虜是否逃跑
                // 獲取俘虜、非俘虜成員的資料
                const prisoners = presentMembers.filter(member => member.type === "俘虜");
                const nonPrisoners = presentMembers.filter(member => member.type !== "俘虜");
   
                // 加總敏捷
                let teamDex = 0;
                nonPrisoners.forEach(member => {
                    teamDex += member.dex.total;
                });

                // 檢查每個俘虜
                prisoners.forEach(member => {
                    // 以雙方敏捷擲骰
                    let result = roll(member.dex.total, teamDex);
                    console.log(`俘虜敏捷: ${member.dex.total}, 隊伍總敏捷: ${teamDex}`);
                    console.log(`俘虜逃跑機率: ${(result.chance*100).toFixed(2)}%`);  // 顯示精確到小數點後2位

                    // 結果
                    if (result.success === true) {
                        // 俘虜逃跑
                        removePresentMembers(member.id); // 移出上場成員
                        removeCompanion(member.id); // 移出隊伍

                        // 顯示俘虜逃跑訊息（顯示在隊伍欄位，因為逃跑成功會清除角色欄位）
                        document.getElementById("team-action").textContent = texts.escapePrisoner(member.name);
                    }
                });

            // 讀取敵人資料
            let enemies = JSON.parse(localStorage.getItem("enemies")) || [];
            let enemyType = enemies.length > 0 ? enemies[0].type : 0;

            // 先將所有敵人加入可行動敵人
            let availableEnemies = [...enemies];
            console.log(availableEnemies);

            // 每個敵人的狀態生效，並減少持續回合
            enemies.forEach(enemy => {
                // 先重置屬性
                ["str", "dex", "con", "int", "wis", "cha", "arm"].forEach(attr => {
                    enemy[attr].status = 0;
                    enemy[attr].total = Object.entries(enemy[attr])
                        .filter(([key]) => key !== "total" && key !== "status") // 過濾掉 "total" 和 "status"
                        .reduce((sum, [, val]) => sum + val, 0); // 累加數值
                });

                // 狀態效果
                enemy.status.forEach(s => {
                    // HP 增減（確保不會超過最大值，也不會小於0）
                    enemy.HP = Math.min(Math.max(enemy.HP + (s.HP || 0), 0), enemy.MaxHP);

                    // 屬性增減
                    ["str", "dex", "con", "int", "wis", "cha", "arm"].forEach(attr => {
                        enemy[attr].status += s[attr] || 0;  // 更新 status 屬性
                        enemy[attr].total += s[attr] || 0;    // 更新 total 屬性
                    });

                    // 無法行動
                    if (s.immobile) {
                        // 移出可行動敵人
                        const targetIndex = availableEnemies.findIndex(e => e.id === enemy.id);
                        if (targetIndex > -1) {
                            availableEnemies.splice(targetIndex, 1);
                        }

                        // 顯示狀態訊息
                        if (s.name === "倒地") {
                            localStorage.setItem(`${enemy.id}-action-text`, texts.prone);
                        } if (s.name === "石化") {
                            localStorage.setItem(`${enemy.id}-action-text`, texts.petrified);
                        }
                    }
                    
                    s.duration --; // 減少持續回合
                });

                // 移除已結束的狀態
                enemy.status = enemy.status.filter(s => s.duration > 0);
            });

            // 儲存更新後的敵人資料
            localStorage.setItem("enemies", JSON.stringify(enemies));
            localStorage.setItem("availableEnemies", JSON.stringify(availableEnemies));

            // 如果敵人毫無防備，下回合恢復正常回合
            let situation = parseInt(localStorage.getItem("situation"));
            if (situation === 4) {
                localStorage.removeItem("situation"); // 清除遇敵方式
            }

            // --------------------------------
            // 敵人回合
            // --------------------------------
            
            document.getElementById("enemy-infor").innerHTML = ""; // 先清空敵人欄位
            // 檢查敵人是否投降
                // 找到 str 最高的成員
                let maxStrMembers = [];
                let maxStr = -Infinity; // 設定初始值為負無限
                presentMembers.forEach(member => {
                    if (member.str.total > maxStr) { // 如果找到更高的 str，重置陣列，將該角色加入陣列
                        maxStr = member.str.total; //更新最高 str
                        maxStrMembers = [member];
                    }
                });

                // 敵人是否投降
                if (enemies.length === 1 && enemyType.includes("智慧") && maxStr > enemies[0].HP && !isTrue("enemySurrender")) {
                    // 如果只剩一個智慧敵人，且隊伍中最高力量 > 敵人 HP 時，且還沒投降過
                        
                    // 以雙方力量擲骰
                    let result = roll(maxStr, enemies[0].str.total);
                    console.log(`隊伍最高力量: ${maxStr}, 敵人力量: ${enemies[0].str.total}`);
                    console.log(`投降機率: ${(result.chance*100).toFixed(2)}%`);  // 顯示精確到小數點後2位

                    // 結果
                    if (result.success === true) {
                        turnSwitch("enemySurrender");
                        localStorage.setItem("npcId", enemies[0].id); // 儲存為交談對象
                        window.location.href = 'battleTalk.html'; // 敵人投降，跳轉到交談頁面
                        return;
                    }
                }

            enemyAction(); // 敵人攻擊
        }

        // 新的我方回合開始
        function newRound() {
            let teamMembers = JSON.parse(localStorage.getItem("teamMembers")) || [];
            let presentMembers = JSON.parse(localStorage.getItem("presentMembers")) || [];

            // 先將所有上場成員加入可行動成員
            let availableMembers = [...presentMembers];  // 使用擴展語法確保availableMembers獨立於presentMembers

            // 角色的狀態生效
            teamMembers.forEach(member => {
                // 先重置屬性
                ["str", "dex", "con", "int", "wis", "cha", "arm"].forEach(attr => {
                    member[attr].status = 0;
                    member[attr].total = Object.entries(member[attr])
                        .filter(([key]) => key !== "total" && key !== "status") // 過濾掉 "total" 和 "status"
                        .reduce((sum, [, val]) => sum + val, 0); // 累加數值
                });

                // 狀態效果
                member.status.forEach(s => {
                    // HP 增減（確保不會超過最大值，也不會小於0）
                    member.HP = Math.min(Math.max(member.HP + (s.HP || 0), 0), member.MaxHP);

                    // 屬性增減
                    ["str", "dex", "con", "int", "wis", "cha", "arm"].forEach(attr => {
                        member[attr].status += s[attr] || 0;  // 更新 status 屬性
                        member[attr].total += s[attr] || 0;    // 更新 total 屬性
                    });

                    // 無法行動
                    if (s.immobile) {
                        // 移出可行動成員
                        const targetIndex = availableMembers.findIndex(e => e.id === member.id);
                        if (targetIndex > -1) {
                            availableMembers.splice(targetIndex, 1);
                        }

                        // 顯示狀態訊息
                        if (s.name === "倒地") {
                            localStorage.setItem(`${member.id}-action-text`, texts.prone);
                        } if (s.name === "石化") {
                            localStorage.setItem(`${member.id}-action-text`, texts.petrified);
                        }
                    }
                });
            });

            // 檢查雷納德是否路過幫忙
                isMember = teamMembers.some(m => m.name === "雷納德");
                const inEvent = localStorage.getItem("inEvent");

                if (!isMember && teamMembers.length < 4 && teamMembers.length > 0 && !inEvent && !isTrue("雷納德路過")) {
                    // 如果雷納德不在隊伍中，隊伍有空位，且不是在事件中，且今天還沒遇過雷納德，雷納德有機率加入
                    let randomValue = Math.random();
                    if (randomValue <= 0.05) { // 5% 機率加入
                        turnSwitch("雷納德路過");
                        localStorage.setItem("npcName", "雷納德");
                        showDialogue("雷納德幫忙");
                    }
                }

            // 儲存更新後的資料
            localStorage.setItem("teamMembers", JSON.stringify(teamMembers));
            localStorage.setItem("availableMembers", JSON.stringify(availableMembers));
            endAction();

            //generateAvatar(); // 更新顯示圖像

            //window.scrollTo({ top: 0, behavior: "smooth" }); // 跳到畫面上方
        }

        // 敵人行動
        function enemyAction() {
            let teamMembers = JSON.parse(localStorage.getItem("teamMembers")) || [];
            let frontMembers = JSON.parse(localStorage.getItem("frontMembers")) || [];
            let presentMembers = JSON.parse(localStorage.getItem("presentMembers")) || [];
            let enemies = JSON.parse(localStorage.getItem("enemies")) || [];
            let availableEnemies = JSON.parse(localStorage.getItem("availableEnemies")) || [];

            // 上場成員已經沒人時（戰敗時讓玩家看情況），直接結束敵人回合
            if (presentMembers.length === 0) {
                turnSwitch("敵人回合", false);
                endAction();
                return;
            }

            // 只執行一個可行動敵人，等待玩家按下一步
            let enemy = enemies.find(e => e.id === availableEnemies[0].id);
            //console.log(enemy);


            // 飛行類敵人，有 20% 機率飛行
            //const flyChance = 0.2;
            //if (enemy.type.includes("飛行") && Math.random() <= flyChance) {
            //    const status = statusData.find(s => s.name === "飛行");
            //    enemy.status.push(status);
            //    localStorage.setItem("enemies", JSON.stringify(enemies));

                // 顯示飛行的訊息
            //    localStorage.setItem(`${enemy.id}-action-text`, texts.enemyFly);
            //    showInfor(enemy);
            //    return;
            //}

            // 從隨機選擇一個目標
            let target;
            if (frontMembers.length > 0) {
                // 優先從前排選擇
                const randomIndex = Math.floor(Math.random() * frontMembers.length);
                target = teamMembers.find(m => m.id === frontMembers[randomIndex].id);
            } else { 
                // 如果前排無人，從上場成員中選擇
                const randomIndex = Math.floor(Math.random() * presentMembers.length);
                target = teamMembers.find(m => m.id === presentMembers[randomIndex].id);
            }

            // 將敵人移出可行動敵人
            availableEnemies = availableEnemies.filter(e => e.id !== enemy.id);
            localStorage.setItem("availableEnemies", JSON.stringify(availableEnemies));

            // 控制開關
            if (availableEnemies.length === 0) {
                turnSwitch("敵人回合", false); // 如果是最後一個，結束敵人回合
                useSkill("attack", enemy.id, target.id); // 攻擊（必須在開關之後處理）
                newRound(); // 新的我方回合開始
            } else {
                turnSwitch("敵人回合"); // 打開
                useSkill("attack", enemy.id, target.id); // 攻擊（必須在開關之後處理）
            }
        }

        // 獲得金錢和戰利品
        function loot() {
            // 讀取所有敵人的資料
            let enemies = JSON.parse(localStorage.getItem("enemies")) || [];

            // 讀取初始敵人數量
            let enemyCount = parseInt(localStorage.getItem("enemyCount"));
                
            // 讀取玩家的金錢與物品
            let playerMoney = parseInt(localStorage.getItem("playerMoney")) || 0;
            let playerItems = JSON.parse(localStorage.getItem("playerItems")) || [];

            let totalMoney = 0;
            let totalLoot = [];

            // 計算金錢和戰利品
            enemies.forEach(enemy => {
                // 金錢
                if (enemy.money) {
                    totalMoney += enemy.money * enemyCount;
                    playerMoney += enemy.money * enemyCount;
                }
                // 戰利品（一般戰利品 + 武器 + 護甲）
                for (let i = 0; i < enemyCount; i++) {
                    // 戰利品
                    if (enemy.loot) {
                        if (Array.isArray(enemy.loot)) {
                            totalLoot = totalLoot.concat(enemy.loot); // 如果 enemy.loot 是陣列，將其所有物品加入 totalLoot
                        } else {
                            totalLoot.push(enemy.loot); // 如果只有一個物品，直接加入
                        }
                    }
                    // 武器和護甲
                    if (enemy.weapon.id) totalLoot.push(enemy.weapon.id);
                    if (enemy.armor.id) totalLoot.push(enemy.armor.id);
                }
            });

            // 更新玩家金錢與物品
            playerItems = playerItems.concat(totalLoot);
            localStorage.setItem("playerItems", JSON.stringify(playerItems));
            localStorage.setItem("playerMoney", playerMoney);

            // 統計戰利品的數量
            let lootCount = totalLoot.reduce((count, loot) => {
                count[loot] = (count[loot] || 0) + 1;
                return count;
            }, {});

            // 顯示獲得的金錢和戰利品
            let lootResult;

            // 獲得的金錢
            let moneyText = totalMoney > 0 ? `獲得 🪙 $${totalMoney}<br>` : "";

            // 獲得的戰利品
            let lootText = Object.keys(lootCount).map(loot => {
                //let item = itemDatabase.find(i => i.id === loot);
                let item = findItemData(loot); // 從資料庫查找物品
                return item ? `獲得 ${item.name} × ${lootCount[loot]}` : "";
            }).filter(text => text !== "").join("<br>");

            lootResult = moneyText + lootText;
            localStorage.setItem("lootResult", lootResult);
        }

        // 戰敗後的處理
        function defeated() {
            // 讀取第一個敵人的類型
            let enemies = JSON.parse(localStorage.getItem("enemies")) || [];
            let enemyType = enemies.length > 0 ? enemies[0].type : 0;

            // 讀取目前已逃跑的成員
            let escapeMember = JSON.parse(localStorage.getItem("escapeMember")) || [];
            let playerEscaped = escapeMember.some(member => member.id === "player");

            const encounter = JSON.parse(localStorage.getItem("encounter"));

            // 決定戰敗的情況
            if (enemyType.includes("類人") && !playerEscaped && !encounter) {
                // 如果是類人敵人、主角沒有逃走，也不是指定戰鬥，就隨機決定情況
                let randomValue = Math.random();

                if (randomValue < 1) { // 100% 被搶劫
                    battleResult = 6;
                } else { // 0% 被抓去當奴隸（尚未實裝）
                    battleResult = 8; 
                }                
                localStorage.setItem("battleResult", battleResult);

            } else { 
                // 否則單純被擊倒
                battleResult = 5;
                localStorage.setItem("battleResult", battleResult);
            }
            
            // 處理戰敗的情況
            if (battleResult === 6) { // 被搶劫的情況
                // 讀取主角金錢
                let playerMoney = parseInt(localStorage.getItem("playerMoney")) || 0;

                // 如果有錢，執行搶劫
                if (playerMoney > 0) {
                    // 隨機決定被搶走的金額（至少 1，最多一半）
                    let robbedMoney = Math.max(1, Math.floor(Math.random() * playerMoney * 0.5));
                    robbedMoney = Math.min(robbedMoney, playerMoney); // 確保不會超過擁有的金額

                    // 扣除金錢並儲存
                    playerMoney -= robbedMoney;
                    localStorage.setItem("playerMoney", playerMoney);
                    localStorage.setItem("robbedMoney", robbedMoney);

                } else {
                    // 沒有錢，改為普通擊倒
                    battleResult = 5;
                    localStorage.setItem("battleResult", battleResult);
                }

            } else if (battleResult === 8) { // 成為奴隸的情況（尚未實裝）

            }

            // 檢查有沒有包裹，隨機損壞一件
                let playerItems = JSON.parse(localStorage.getItem("playerItems")) || [];
                let packages = playerItems.filter(item => item === "package01" || item === "package02");

                if (packages.length > 0) {
                    // 隨機選擇一件包裹
                    let randomPackage = packages[Math.floor(Math.random() * packages.length)];

                    // 根據這個包裹的id替換為損壞包裹
                    playerItems = playerItems.map(item => {
                        if (item === randomPackage) {
                            return randomPackage === "package01" ? "package01_damaged" : "package02_damaged"; // 替換為損壞版本
                        }
                        return item; // 保留其他包裹不變
                    });

                    // 更新 localStorage
                    localStorage.setItem("playerItems", JSON.stringify(playerItems));
                }

            // 如果有指定戰敗後的對話
            if (encounter && encounter.failKey) {
                localStorage.setItem("currentKey", encounter.failKey);
            } else {
                localStorage.removeItem("inEvent"); // 清除事件
            }
                
            turnSwitch("幫助平民", false); // 清除幫助平民

            // 隨機決定重生的情況
            let respawn;
            let randomValue = Math.random();
            if (randomValue < 0.5) { // 50% 原地重生
                respawn = 1; 
            } else { // 50% 被送回城鎮
                respawn = 2; 
            }

            // 如果在事件中，只會原地重生
            const inEvent = localStorage.getItem("inEvent");
            if (inEvent) {
                respawn = 1; 
            }
            
            // 如果指定敵人是守衛，就會被逮捕
            if (encounter && encounter.enemyName === "守衛") {
                respawn = 3; // 在監獄重生
            }

            // 儲存重生的情況
            localStorage.setItem("respawn", respawn);
        }

        // 戰鬥結束
        function endBattle() {  
            window.location.href = 'battleResult.html'; // 跳轉到戰鬥結果頁面
        }

        // 幫手加入
        function helperJoin() {
            // 加入隊伍
            const npcName = localStorage.getItem("npcName");
            let companion = mercenaries.find(comp => comp.name === npcName);
            addCompanion(companion);

            // 找到隊中的id
            const teamMembers = JSON.parse(localStorage.getItem("teamMembers")) || [];
            let member = teamMembers.find(m => m.name === npcName);

            // 加入上場成員、可行動成員
            let presentMembers = JSON.parse(localStorage.getItem("presentMembers")) || [];
            let availableMembers = JSON.parse(localStorage.getItem("availableMembers")) || [];
            presentMembers.push(member);
            availableMembers.push(member);
            localStorage.setItem("presentMembers", JSON.stringify(presentMembers));
            localStorage.setItem("availableMembers", JSON.stringify(availableMembers));

            generateAvatar(); // 更新顯示圖像
        }

        // 附加狀態
        function giveStatus(weapon, target) {
            if (weapon && weapon.addStatus) {
                // 用武器的附加機率擲骰（不用過屬性檢定）
                let success = Math.random() <= weapon.addChance;
                console.log(`狀態附加成功率: ${(weapon.addChance*100)}%`);
                
                // 附加成功
                if (success) {
                    let status = statusData.find(sta => sta.name === weapon.addStatus);
                    target.status.push(status);
                    return status.name;
                }
            }
        }

    </script>

</body>
</html>
