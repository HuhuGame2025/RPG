<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>戰鬥</title>
    <link rel="stylesheet" href="style.css">
    <style>
        body {
        }
    </style>
</head>
<body>
    <!-- 按鈕列 -->
    <div class="button-bar" id="buttonBar">
        <a href="menu/character.html">🎭<span>角色</span></a>
        <a href="menu/quest.html">📜<span>任務</span></a>
        <a>🚫<span class="warn">物品</span></a>
        <a href="menu/option.html">⚙️<span>選項</span></a>
    </div>

    <!-- 主要內容區域 -->
    <div id="main" class="main-content">
        <h3 id="situation"></h3>
        <p id="battle-result"></p>
        <p id="respawn-result"></p>

        <div id="battle-content">
            <div class="item bottomborder center small">
                <span>➵ 敵方</span>
            </div>

            <!-- 敵人列表 -->
            <div id="enemy-list"></div>

            <div class="item bottomborder center small">
                <span> 我方 ➵</span>
            </div>

            <!-- 提示 -->
            <p class="note" id="note"></p>
            <p id="soul-count"></p>

            <!-- 隊伍列表 -->
            <div id="member-list"></div>

            <!-- 隊伍按鈕 -->
            <p id="team-action"></p>
            <div class="menu">
                <div class="menu team-btn">
                    <button onclick="selectAttacker('team')">⚔️聯手攻擊</span></button>
                    <button onclick="escape('team')">🏃一起逃跑</span></button>
                </div>
                <br>
                <button onclick="endRound()">結束回合</button>
            </div>
        </div>
    </div>

    <!-- 對話區域 -->
    <div id="dialogue" class="main-content"></div>

    <script src="script.js"></script>
    <script>

        // 顯示文本
        const texts = {
            noTarget: "請選擇一個敵人為目標",
            noAttacker: "請選擇我方的行動",
            fightWin: (name, damage) => `擊中${name}(${damage})！`,
            fightWinWithStatus: (name, damage, status) => `擊中${name}(${damage})，使他${status}了！`,
            fightLose: (name) => `試圖攻擊${name}，但被躲開了`,
            fightFlyingEnemy: (name) => `${name}飛得太高，無法擊中`,
            killEnemy: (name, damage) => `打敗了${name}(${damage})！`,
            die: (deadMembers) => `${deadMembers}倒下了！`,
            teamFightWin: (name, damage) => `你們聯手，對${name}造成了重創！(${damage})`,
            teamFightLose: (name) => `${name}非常頑強，避開了所有的攻擊`,
            teamKillEnemy: (name, damage) => `你們聯手打敗${name}(${damage})！`,
            escapeSuccess: (name) => `${name}逃走了`,
            escapeFail: (name) => `敵人阻擋了${name}的去路！`,
            teamEscapeFail: (name) => `${name}跑不過敵人，你們只好停下來！`,
            enemyWin: (name, damage) => `擊中${name}(${damage})！`,
            enemyWinWithStatus: (name, damage, status) => `擊中${name}(${damage})，使他${status}了！`,
            enemyLose: (name) => `試圖攻擊${name}，但被躲開了`,
            enemyKill: (name, damage) => `打敗了${name}(${damage})！`,
            enemyFly: "飛上了高空",
            safe: "順利前進",
            battle: "敵人出現了！",
            surprise: "遭到偷襲了！",
            cannotTalk: "敵人無法理解你說的話。",
            escapePrisoner: (name) => `${name}趁你在對付敵人時逃走了！`,
            demonAttacked: "燃燒了起來",
            bleeding: "流血了",
            prone: "從地上起身",
            petrified: "變成石頭，無法動彈",
            //trap: "觸發陷阱！",
            //enemyComing: "敵人正在趕來的路上，最好快點離開",
        };

        // 畫面載入時
        window.onload = function() {
            getSituation(); // 讀取並執行遇敵方式
            loadBackground(); // 讀取背景
            npcPreferences(); // NPC偏好設定
        };

        // 對話資料庫
        const dialogueData = {
            "雷納德": {
                "雷納德幫忙": {
                    npc: "npc",
                    text: "沒事吧？你需要幫忙嗎？",
                    choices: [
                        { text: "拜託了", next: "", action: "(helperJoin(), removeDialogue(), getSituation())" },
                        { text: "不用幫忙", next: "", action: "(removeDialogue(), getSituation())" },
                    ]
                },
            },
        }

        let enemy = {}; // 當前敵人
        let escapeMember= []; // 逃跑成員

        // 讀取並執行遇敵方式
        function getSituation() {
            let situation = parseInt(localStorage.getItem("situation"));
            //situation = 3; // 測試用

            let enemies = JSON.parse(localStorage.getItem("enemies")) || [];

            if (situation === 2 || situation === 5 || situation === 7) {
                // 顯示敵人準備戰鬥的描述
                enemies.forEach(enemy => {
                    localStorage.setItem(`${enemy.id}-action-text`, enemy.actionBattle);
                });

                document.getElementById("situation").textContent = texts.battle; // 顯示遇敵的訊息
                localStorage.removeItem("situation"); // 清除遇敵方式
                console.log("一般遇敵（我方先攻）");

            } else if (situation === 3) {
                document.getElementById("situation").textContent = texts.surprise; // 顯示被偷襲的訊
                localStorage.removeItem("situation"); // 清除遇敵方式
                console.log("被偷襲（敵人先攻）");

                startBattle() // 開始戰鬥
                enemyFight(); // 敵人攻擊

            } else if (situation === 4) {
                // 顯示敵人沒有防備的描述
                enemies.forEach(enemy => {
                    localStorage.setItem(`${enemy.id}-action-text`, enemy.action);
                });
                console.log("發現無防備的敵人（我方第一回合攻擊、逃跑100%成功）");
            }
            startBattle() // 開始戰鬥
        }

        // 開始戰鬥
        function startBattle() {
            loadPartyData(); // 讀取隊伍資料
            //generateTeam(); // 顯示上場成員欄位及按鈕（已包含在endAction）
            //generateEnemy(); // 顯示敵人（已包含在endAction）
            endAction(); // 每次載入時跑一次，以防有東西還原
        }

        // 顯示上場成員
        function generateTeam() {
            presentMembers = JSON.parse(localStorage.getItem("presentMembers")) || [];
            availableMember = JSON.parse(localStorage.getItem("availableMember")) || [];

            const menu = document.getElementById("member-list");
            menu.innerHTML = "";  // 清空選單內容

            // 創建每個成員的資料
            presentMembers.forEach(member => {
                let isAvailable = availableMember.some(m => m.id === member.id);
                let isPlayer = member.id === "player";

                // 取得武器 emoji
                let weaponIcon = "✊"; // 預設空手
                if (member.weapon && member.weapon.id) {
                    weaponIcon = Array.from(member.weapon.name)[0];  // 取第一個字符（emoji）
                }

                const characterDiv = document.createElement("div");
                characterDiv.innerHTML = `
                    <div id="${member.id}" class="item background">
                        <div class="column-container">
                            <div class="column">
                                <h4>${weaponIcon} ${member.name}</h4>
                            </div>
                            <div class="column center">
                                <h4 class="hp"><span id="${member.id}-HP">${member.HP}</span> / ${member.MaxHP}</h4>
                            </div>
                        </div>

                        <p id="${member.id}-status"></p>
                        <p id="${member.id}-action" class="battle-text"></p>

                        ${isAvailable ? `
                            <div class="row-buttons ${member.id}-btn">
                                ${isPlayer ? `
                                    <button onclick="talk()">💬<br><span class="small">交談</span></button>
                                ` : "" }
                                <button onclick="selectAttacker('${member.id}')">⚔️<br><span class="small">攻擊</span></button>
                                <button onclick="useItem('${member.id}')">💰<br><span class="small">物品</span></button>
                                <button onclick="escape('${member.id}')">🏃<br><span class="small">逃跑</span></button>
                            </div>
                        ` : "" }
                    </div>
                `;
                menu.appendChild(characterDiv);

                // 顯示訊息
                const message = localStorage.getItem(`${member.id}-action-text`) || "";
                document.getElementById(`${member.id}-action`).textContent = message;

                // HP改為紅字
                const redHP = JSON.parse(localStorage.getItem("redHP")) || [];
                redHP.forEach(HP => {
                    if (document.getElementById(HP)) {
                        document.getElementById(HP).classList.add("red-hp");
                    }
                });

                // 取得狀態圖示
                const statusList = document.getElementById(`${member.id}-status`);
                statusList.innerHTML = "";  // 清空選單內容
                member.status.forEach(status => {
                    // 生成說明文字
                    const infor = `【${status.name}】${status.description}（剩餘回合：${status.duration}）`;

                    // 顯示圖示按鈕
                    const statusDiv = document.createElement("span");
                    statusDiv.innerHTML = `
                        <button onClick="alert('${infor}')" class="status-button">${status.icon}</button>
                    `;
                    statusList.appendChild(statusDiv);
                });
            });

            // 檢查是否顯示隊伍按鈕
            if (availableMember.length < 2) {
                // 如果可行動的隊員不到 2 個，隱藏隊伍按鈕
                document.querySelectorAll('.team-btn button').forEach(button => {
                    button.style.display = "none";
                });
            } else {
                // 否則顯示
                document.querySelectorAll('.team-btn button').forEach(button => {
                    button.style.display = "block";
                });
            }

            // 如果物品中有可用的紅寶石，就顯示已獻祭的數量
                const playerItems = JSON.parse(localStorage.getItem("playerItems")) || [];
                const ruby = playerItems.find(i => i === "specialItem14");
                if (ruby) {
                    const soulCount = parseInt(localStorage.getItem("soulCount"));
                    document.getElementById('soul-count').textContent = "💀 " + soulCount;
                }
            
            //console.log("可行動的成員", availableMember);
        }

        // 顯示敵人
        function generateEnemy() {
            let enemies = JSON.parse(localStorage.getItem("enemies")) || [];

            const menu = document.getElementById("enemy-list");
            menu.innerHTML = "";  // 清空選單內容

            // 創建每個敵人的資料
            enemies.forEach(enemy => {
                const characterDiv = document.createElement("div");
                characterDiv.innerHTML = `
                    <div id="${enemy.id}" class="item background" onclick="selectTarget('${enemy.id}', this)" style="cursor: pointer;">
                        <div class="column-container">
                            <div class="column">
                                <h4>${enemy.adj}${enemy.name}</span></h4>
                            </div>
                            <div class="column center">
                                <h4 class="hp"><span id="${enemy.id}-HP">${enemy.HP}</span> / ${enemy.MaxHP}</h4>
                            </div>
                        </div>

                        <p id="${enemy.id}-status"></p>
                        <p id="${enemy.id}-action" class="battle-text"></p>
                    </div>
                `;
                menu.appendChild(characterDiv);

                // 顯示訊息
                const message = localStorage.getItem(`${enemy.id}-action-text`) || "";
                document.getElementById(`${enemy.id}-action`).textContent = message;

                // HP改為紅字
                const redHP = JSON.parse(localStorage.getItem("redHP")) || [];
                redHP.forEach(HP => {
                    if (document.getElementById(HP)) {
                        document.getElementById(HP).classList.add("red-hp");
                    }
                });

                // 取得狀態圖示
                const statusList = document.getElementById(`${enemy.id}-status`);
                statusList.innerHTML = "";  // 清空選單內容
                enemy.status.forEach(status => {
                    // 生成說明文字
                    const infor = `【${status.name}】${status.description}（剩餘回合：${status.duration}）`;

                    // 顯示圖示按鈕
                    const statusDiv = document.createElement("span");
                    statusDiv.innerHTML = `
                        <button onClick="alert('${infor}')" class="status-button">${status.icon}</button>
                    `;
                    statusList.appendChild(statusDiv);
                    console.log(status.icon);
                });

                // 如果已選為目標，加上 selected class
                const selectedTarget = localStorage.getItem("selectedTarget");
                if (selectedTarget === enemy.id) {
                    document.getElementById(`${enemy.id}`).classList.add("selected");
                }
            });
            console.log("敵人:", enemies);
        }

        let selectedAttacker = null; // 記錄攻擊者

        // 選擇攻擊者（角色或同伴）
        function selectAttacker(attackerId) {
            // 將選擇的角色設為攻擊者
            selectedAttacker = attackerId;
            checkAndExecuteFight();
        }

        // 選擇目標敵人
        function selectTarget(targetId, button) {
            // 移除所有目標按鈕的 selected class
            document.querySelectorAll("button[id^='enemy']").forEach(btn => {
                btn.classList.remove("selected");
            });

            // 為當前選中的按鈕加上 selected class
            button.classList.add("selected");

            // 將選擇的敵人設為目標（儲存目標以防頁面刷新）
            localStorage.setItem("selectedTarget", targetId);

            checkAndExecuteFight();
            // 如果已選擇攻擊者，就進入戰鬥
        }

        // 檢查是否已選擇攻擊者和目標，然後執行攻擊
        function checkAndExecuteFight() {
            const selectedTarget = localStorage.getItem("selectedTarget");

            if (!selectedTarget) {
                // 如果沒選攻擊者
                document.getElementById("note").textContent = texts.noTarget;
            } else if (!selectedAttacker) {
                // 如果沒選目標
                document.getElementById("note").textContent = texts.noAttacker;
            } else { 
                // 如果都有，執行攻擊邏輯
                fight(selectedAttacker, selectedTarget);
                selectedAttacker = null; // 重置攻擊者
            }
        }

        // 攻擊邏輯
        function fight(attackerId, target) {            
            // 獲取敵人資料
            let enemies = JSON.parse(localStorage.getItem("enemies")) || [];
            let targetEnemy = enemies.find(e => e.id === target);
            let enemyName = targetEnemy.adj + targetEnemy.name;

            // 讀取可行動成員的資料
            let availableMember = JSON.parse(localStorage.getItem("availableMember")) || [];
          
            // 確認攻擊者人數
            let attacker = [];
            if (attackerId === "team") {
                // 聯手攻擊，計入所有可行動成員
                attacker = availableMember;
            } else {
                // 單獨攻擊，找到攻擊者
                singleAttacker  = availableMember.find(comp => comp.id === attackerId);
                attacker = [singleAttacker]; // 包成陣列
            }

            // 如果敵人飛行中，只計入有遠程武器的成員
            let isFly = Object.values(targetEnemy.status).some(s => s.name === "飛行");
            if (isFly) {
                attacker = attacker.filter(member => member.weapon && member.weapon.category === "遠程");
            }

            // 取得攻擊者資料
            let attackerName = [], attackerDex = 0, attackerStr = 0, attackerWeapon = [];
            attacker.forEach(member => {
                attackerName.push(member.name);
                attackerDex += member.dex.total; // 我方總敏捷
                attackerStr += member.str.total; // 我方總力量
                attackerWeapon.push(member.weapon); // 我方武器
            });

            // 以雙方敏捷擲骰
            let result = roll(attackerDex, targetEnemy.dex.total);

            // 檢查是否有例外
            let situation = parseInt(localStorage.getItem("situation"));
            let isPlant = targetEnemy.type.includes("植物");
            let isProne = Object.values(targetEnemy.status).some(s => s.name === "倒地");

            if (situation === 4 || isProne || isPlant) { 
                // 如果敵人無防備、目標倒地、目標是植物，自動成功
                result = { success: true, chance: 1 };
            }
            console.log(`攻擊者: ${attackerName}, 敏捷: ${attackerDex}, 目標: ${target}, 目標敏捷: ${targetEnemy.dex.total}`);
            console.log(`攻擊命中率: ${(result.chance*100).toFixed(2)}%`);  // 顯示精確到小數點後2位

            // 攻擊結果
            if (result.success === true) {
                // 攻擊成功，對目標造成傷害
                let damage = Math.max(attackerStr - targetEnemy.arm.total, 0); // 傷害 = 我方力量總和 - 敵人護甲
                targetEnemy.HP = Math.max(targetEnemy.HP - damage, 0); // HP 減少，不會低於0
                document.getElementById(`${target}-HP`).textContent = targetEnemy.HP;

                // HP 變為紅字（只有一個）
                let redHP = [];
                redHP.push(`${target}-HP`);
                localStorage.setItem("redHP", JSON.stringify(redHP));

                // 檢查敵人是否死亡
                if (targetEnemy.HP <= 0) {
                    // 敵人死亡
                    if (attackerId === "team") {
                        // 顯示聯手擊殺訊息（在隊伍的欄位）
                        document.getElementById("team-action").textContent = texts.teamKillEnemy(enemyName, damage);
                    } else {
                        // 顯示單獨擊殺訊息（在攻擊者的欄位）
                        localStorage.setItem(`${attackerId}-action-text`, texts.killEnemy(enemyName, damage));
                    }
                    // 清除目標
                    localStorage.removeItem("selectedTarget");

                } else {
                    // 敵人活著
                    if (attackerId === "team") {
                        // 顯示聯手攻擊成功訊息（在隊伍的欄位）
                        localStorage.setItem(`${attackerId}-action-text`, texts.teamFightWin(enemyName, damage));

                    } else {
                        // 顯示單獨攻擊成功訊息（在攻擊者的欄位）
                        localStorage.setItem(`${attackerId}-action-text`, texts.fightWin(enemyName, damage));
                    }

                    // 附加狀態
                    attackerWeapon.forEach(weapon => {
                        let statusName = giveStatus(weapon, targetEnemy);
                        if (statusName) {
                            // 顯示附加的訊息
                            localStorage.setItem(`${attackerId}-action-text`, texts.fightWinWithStatus(enemyName, damage, statusName));
                            console.log("造成" + statusName);
                        };
                    });
                };

                localStorage.setItem("enemies", JSON.stringify(enemies));  // 儲存更新後的敵人資料

            } else {
                // 攻擊失敗

                if (isFly && attackerDex === 0) {
                    // 如果失敗是因為目標在飛行，且沒有遠程武器
                    if (attackerId === "team") {
                        // 顯示聯手攻擊無法觸及訊息（在隊伍的欄位）
                        document.getElementById("team-action").textContent = texts.fightFlyingEnemy(enemyName);
                    } else {
                        // 顯示單獨攻擊無法觸及訊息（在攻擊者的欄位）
                        localStorage.setItem(`${attackerId}-action-text`, texts.fightFlyingEnemy(enemyName));
                    }
                    
                } else {
                    // 預設情況
                    if (attackerId === "team") {
                        // 顯示聯手攻擊失敗訊息（在隊伍的欄位）
                        document.getElementById("team-action").textContent = texts.teamFightLose(enemyName);
                    } else {
                        // 顯示單獨攻擊失敗訊息（在攻擊者的欄位）
                        localStorage.setItem(`${attackerId}-action-text`, texts.fightLose(enemyName));
                    }
                }
            }

            // 攻擊結束後
            if (attackerId === "team") {
                // 聯手攻擊，隱藏可行動成員的攻擊、逃跑按鈕
                availableMember.forEach(member => {
                    document.querySelectorAll(`.${member.id}-btn button`).forEach(button => {
                        button.style.display = "none";
                    });

                    removeavailableMember(member.id); // 將攻擊者移出可行動成員
                });

                // 隱藏聯手攻擊、一起逃跑按鈕
                document.querySelectorAll('.team-btn button').forEach(button => {
                    button.style.display = "none";
                });
            } else {
                // 單獨攻擊，隱藏攻擊者的攻擊、逃跑按鈕
                document.querySelectorAll(`.${attackerId}-btn button`).forEach(button => {
                    button.style.display = "none";
                });

                removeavailableMember(attackerId); // 將攻擊者移出可行動成員
            }

            endAction();
        }

        // 逃跑邏輯
        function escape(escaper) {
            let presentMembers = JSON.parse(localStorage.getItem("presentMembers")) || [];
            let availableMember = JSON.parse(localStorage.getItem("availableMember")) || [];

            let escaperName;
            let escaperDex = 0; // 我方總敏捷
            let minDexMembers = [];
          
            if (escaper === "team") {
                // 一起逃跑，找到 dex 最低的成員資料
                let minDex = Infinity; // 設定初始值為無限大
                availableMember.forEach(member => {
                    if (member.dex.total < minDex) { // 如果找到更低的 dex，重置陣列，將該角色加入陣列
                        minDex = member.dex.total; //更新最低 dex
                        minDexMembers = [member];
                    } else if (member.dex.total === minDex) {
                        minDexMembers.push(member); // 如果dex相同，將該角色加入陣列
                    }
                });
                escaperName = "一起";
                escaperDex = minDex;
            } else {
                // 單獨逃跑，找到逃跑者的資料
                let member = availableMember.find(comp => comp.id === escaper);
                escaperName = member.name;
                escaperDex = member.dex.total;
            }

            // 讀取第一個敵人的資料
            let enemies = JSON.parse(localStorage.getItem("enemies")) || [];
            let enemyDex = enemies.length > 0 ? enemies[0].dex.total : 0; // 取第一個敵人的敏捷
            let enemyType = enemies.length > 0 ? enemies[0].type : ""; // 取第一個敵人的類型
            let availableEnemies = JSON.parse(localStorage.getItem("availableEnemies")) || [];

            // 以雙方敏捷擲骰
            let result = roll(escaperDex, enemyDex);

            // 檢查是否有例外
            let situation = parseInt(localStorage.getItem("situation"));
            let isPlant = enemyType.includes("植物");
            let AllProne = enemies.filter(s => !s.status.some(s => s.name === "倒地")).length === 0;

            if (situation === 4 || isPlant ||  AllProne) { 
                // 如果敵人無防備、敵人是植物、敵人全倒地，自動成功
                result = { success: true, chance: 1 };
            } else if (escaper !== "team" && presentMembers.length > availableEnemies.length) {
                // 如果單獨逃跑時，上場成員比可行動敵人多，敵人就無法分心追趕，自動成功
                result = { success: true, chance: 1 };
            }
            console.log(`逃跑者: ${escaperName}, 敏捷: ${escaperDex}, 敵人敏捷: ${enemyDex}`);
            console.log(`逃跑成功率: ${(result.chance*100).toFixed(2)}%`);

            // 逃跑結果
            if (result.success === true) {
                // 逃跑成功
                if (escaper === "team") {
                    availableMember.forEach(member => {
                        removepresentMembers(member.id); // 移出上場成員
                        addEscapeMember(member.id); // 加入逃跑成員
                    });

                    // 取得所有逃跑成員的名字並用頓號「、」分隔
                    let escapers = availableMember.map(member => member.name).join("、");

                    // 顯示一起逃跑成功訊息
                    document.getElementById("team-action").textContent = texts.escapeSuccess(escapers);
                } else {
                    removepresentMembers(escaper); // 移出上場成員
                    addEscapeMember(escaper); // 加入逃跑成員

                    // 顯示單獨逃跑成功訊息（顯示在隊伍欄位，因為逃跑成功會清除角色欄位）
                    document.getElementById("team-action").textContent = texts.escapeSuccess(escaperName);
                }

            } else {
                // 逃跑失敗
                if (escaper === "team") {
                    // 取得敏捷最低者的名字並用頓號「、」分隔
                    escapers = minDexMembers.map(member => member.name).join("、");

                    // 顯示一起逃跑失敗訊息
                    document.getElementById("team-action").textContent = texts.teamEscapeFail(escapers);               
                } else {
                    // 顯示單獨逃跑失敗訊息（在逃跑者的欄位）
                    //document.getElementById(`${escaper}-action`).textContent = texts.escapeFail(escaperName);
                    localStorage.setItem(`${escaper}-action-text`, texts.escapeFail(escaperName));
                }
            }

            // 逃跑結束後
            if (escaper === "team") {
                // 一起逃跑，隱藏可行動成員的攻擊、逃跑按鈕
                availableMember.forEach(member => {
                    document.querySelectorAll(`.${member.id}-btn button`).forEach(button => {
                        button.style.display = "none";
                    });
                    //localStorage.removeItem(`${member.id}-btn-show`); // 隱藏按鈕

                    removeavailableMember(member.id); // 將攻擊者移出可行動成員
                });

                // 隱藏聯手攻擊和一起逃跑按鈕
                document.querySelectorAll('.team-btn button').forEach(button => {
                    button.style.display = "none";
                });
            } else {
                // 單獨攻擊，隱藏逃跑者的攻擊、逃跑按鈕
                document.querySelectorAll(`.${escaper}-btn button`).forEach(button => {
                    button.style.display = "none";
                });
                //localStorage.removeItem(`${escaper}-btn-show`);  // 隱藏按鈕

                removeavailableMember(escaper); // 將逃跑者移出可行動成員
            }

            endAction();
        }

        // 使用物品
        function useItem(userId) {
            removeavailableMember(userId); // 移出可行動成員
            window.location.href = 'menu/inventory.html'; // 跳轉到物品頁面
        }

        // 交談
        function talk() {
            // 讀取所有敵人的資料
            let enemies = JSON.parse(localStorage.getItem("enemies")) || [];
            let enemyType = enemies.length > 0 ? enemies[0].type : ""; // 取第一個敵人的類型
            const selectedTarget = localStorage.getItem("selectedTarget");

            // 檢查敵人類型是不是智慧
            if (enemyType.includes("智慧")) {
                if (selectedTarget) {
                    // 如果已選擇目標，就進入交談
                    localStorage.setItem("npcId", selectedTarget); // 儲存交談對象

                    // 隱藏主角的攻擊、逃跑按鈕
                    document.querySelectorAll("player-btn button").forEach(button => {
                        button.style.display = "none";
                    });
                    //localStorage.removeItem("player-btn-show"); // 隱藏按鈕
                    removeavailableMember("player"); // 將主角移出可行動成員
                    
                    window.location.href = 'battleTalk.html'; // 跳轉到交談頁面

                } else {
                    // 如果還沒選擇目標，就顯示提示
                    document.getElementById("note").textContent = texts.noTarget;
                }
            } else {
                // 如果不是智慧，就顯示無法對話的提示
                document.getElementById("note").textContent = texts.cannotTalk;
            }
        }

        // 敵人攻擊邏輯
        function enemyFight() {
            // 讀取同伴資料
            let teamMembers = JSON.parse(localStorage.getItem("teamMembers"))

            // 讀取第一個敵人的資料
            let enemies = JSON.parse(localStorage.getItem("enemies")) || [];
            let enemyType = enemies.length > 0 ? enemies[0].type : 0;
            let enemyDex = enemies[0].dex.total; 
            let enemyStr = enemies[0].str.total;

            // 讀取可行動敵人
            let availableEnemies = JSON.parse(localStorage.getItem("availableEnemies"))

            // 每個敵人行動
            enemies.forEach(enemy => {
                // 無法行動則中止
                let isAvailable = availableEnemies.some(e => e.id === enemy.id);
                if (!isAvailable) return;

                // 若上場成員沒人則中止（戰敗時讓玩家看情況）
                if (presentMembers.length === 0) return;

                // 如果是飛行類敵人，有 20% 機率飛行
                if (enemyType.includes("飛行")) {
                    if (Math.random() <= 0.2) {
                        const fly = statusData.find(s => s.name === "飛行");
                        enemy.status.push(fly);
                        localStorage.setItem("enemies", JSON.stringify(enemies));

                        // 顯示飛行的訊息
                        localStorage.setItem(`${enemy.id}-action-text`, texts.enemyFly);
                        return;
                    }
                }

                // 隨機選擇一個目標
                let randomIndex = Math.floor(Math.random() * presentMembers.length);
                let hurtMember = teamMembers.find(m => m.id === presentMembers[randomIndex].id);

                // 以雙方敏捷擲骰
                let result = roll(enemyDex, hurtMember.dex.total);

                // 檢查是否有例外
                let isProne = Object.values(hurtMember.status).some(s => s.name === "倒地");
                let situation = parseInt(localStorage.getItem("situation"));

                if (situation === 4 || isProne) { 
                    // 如果目標倒地，自動成功
                    result = { success: true, chance: 1 };
                }

                console.log(`攻擊者: ${enemy.name}, 敏捷: ${enemyDex}, 目標: ${hurtMember.name}, 目標敏捷: ${hurtMember.dex.total}`);
                console.log(`計算的敵人命中率: ${(result.chance*100).toFixed(2)}%`);  // 顯示精確到小數點後2位

                // 攻擊結果
                if (result.success === true) {
                    // 敵人攻擊成功，對角色造成傷害
                    let damage = Math.max(enemyStr - hurtMember.arm.total, 0); // 傷害 = 攻擊者的力量 - 目標的護甲
                    hurtMember.HP = Math.max(hurtMember.HP - damage, 0); // HP減少，不會低於0
                    document.getElementById(`${hurtMember.id}-HP`).textContent = hurtMember.HP;

                    // HP變為紅字（不移除之前的紅字，可以同時有多個紅字）
                    let redHP = JSON.parse(localStorage.getItem("redHP")) || [];
                    redHP.push(`${hurtMember.id}-HP`);
                    localStorage.setItem("redHP", JSON.stringify(redHP));
                    
                    // 判斷角色是否死亡
                    if (hurtMember.HP <= 0) {
                        // 如果角色死亡，顯示被擊殺訊息（在敵人的欄位）
                        localStorage.setItem(`${enemy.id}-action-text`, texts.enemyKill(hurtMember.name, damage));

                    } else {
                        // 如果角色活著，顯示被攻擊訊息（在敵人的欄位）
                        localStorage.setItem(`${enemy.id}-action-text`, texts.enemyWin(hurtMember.name, damage));

                        // 附加狀態（來自敵人的能力或武器）
                        let statusName;
                        if (enemy.addStatus) {
                            statusName = giveStatus(enemy, hurtMember);
                        } else {
                            statusName = giveStatus(enemy.weapon, hurtMember);
                        }

                        if (statusName) {
                            // 顯示附加的訊息（在敵人的欄位）
                            localStorage.setItem(`${enemy.id}-action-text`, texts.enemyWinWithStatus(hurtMember.name, damage, statusName));
                            console.log("造成" + statusName);
                        }
                    }
                    localStorage.setItem("teamMembers", JSON.stringify(teamMembers));

                } else {
                    // 敵人攻擊失敗，顯示訊息（在敵人的欄位）
                    localStorage.setItem(`${enemy.id}-action-text`, texts.enemyLose(hurtMember.name));
                }
                endAction();
            })
        }

        // 角色離開上場成員
        function removepresentMembers(removeMember) {
            let index = presentMembers.findIndex(member => member.id === removeMember);

            if (index !== -1) {
                let removedMember = presentMembers.splice(index, 1)[0]; // 移除並返回該成員
                console.log(`${removedMember.name} 離開了隊伍`);
            } else {
                console.warn(`無效的同伴: ${removeMember}`);
            }
            localStorage.setItem("presentMembers", JSON.stringify(presentMembers));
            console.log("剩餘成員：", presentMembers.map(m => m.name));
        }

        // 角色離開可行動隊伍
        function removeavailableMember(removeMember) {
            let index = availableMember.findIndex(member => member.id === removeMember);

            if (index !== -1) {
                let removedMember = availableMember.splice(index, 1)[0]; // 移除並返回該成員
                //console.log(`${removedMember.name} 離開了隊伍`);
            } else {
                //console.warn(`無效的同伴: ${removeMember}`);
            }
            localStorage.setItem("availableMember", JSON.stringify(availableMember));
            //console.log("還沒行動過的成員：", availableMember.map(m => m.name));
        }

        // 角色加入逃跑成員
        function addEscapeMember(escaper) {
            // 讀取目前已逃跑的成員
            let escapeMember = JSON.parse(localStorage.getItem("escapeMember")) || [];
            
            // 讀取可行動成員的資料
            let availableMember = JSON.parse(localStorage.getItem("availableMember")) || [];
            
            // 找到逃跑者的名字
            let member = availableMember.find(comp => comp.id === escaper);

            //加入逃跑成員
            escapeMember.push(member);

            localStorage.setItem("escapeMember", JSON.stringify(escapeMember));
            console.log("已逃跑成員：", escapeMember.map(m => m.name));
        }

        // 行動結束（敵我通用）
        function endAction() {  
            // 移除提示
            document.getElementById("note").textContent = "";
            document.getElementById("battle-result").textContent = "";

            let battleResult = 0;
            let respawn = 0;

            // 讀取所有敵人資料
            let enemies = JSON.parse(localStorage.getItem("enemies")) || [];

            // 如果殺死守衛，通緝等級上升，名聲下降
            enemies.forEach(enemy => {
                if (enemy.name === "守衛" && enemy.HP === 0) {
                    addWantedLevel(5);
                    addPlayerFame(-5);
                }
            });

            // 計算獻祭的靈魂數量
            enemies.forEach(enemy => {
                if (enemy.HP === 0) {
                    let soulCount = parseInt(localStorage.getItem("soulCount"));
                    soulCount ++; // 靈魂增加
                    localStorage.setItem("soulCount", soulCount);
                }
            });

            // 檢查是否執行惡魔攻擊
            const demonAttack = localStorage.getItem("demonAttack");
            if (demonAttack) {
                enemies.forEach(enemy => {
                    let damage = 10; // 傷害 = 10
                    enemy.HP = Math.max(enemy.HP - damage, 0); // HP 減少，不會低於0

                    // HP變為紅字
                    //document.getElementById(`${enemy.id}-HP`).classList.add("red-hp");
                    let redHP = [];
                    redHP.push(`${enemy.id}-HP`);
                    localStorage.setItem("redHP", JSON.stringify(redHP));

                    // 顯示敵人燃燒的描述
                    //document.getElementById(`${enemy.id}-action`).textContent = texts.demonAttacked;
                    localStorage.setItem(`${enemy.id}-action-text`, texts.demonAttacked);
                });
                localStorage.setItem("enemies", JSON.stringify(enemies)); // 儲存更新後的敵人資料
                localStorage.removeItem("demonAttack"); // 清除惡魔攻擊
            }

            // 讀取成員資料
            const teamMembers = JSON.parse(localStorage.getItem("teamMembers")) || [];
            let presentMembers = JSON.parse(localStorage.getItem("presentMembers")) || [];
            let availableMember = JSON.parse(localStorage.getItem("availableMember")) || [];
            let escapeMember = JSON.parse(localStorage.getItem("escapeMember")) || [];

            // 同步更新角色 HP、狀態
            presentMembers.forEach(member => {
                let existingMember = teamMembers.find(m => m.id === member.id);
                if (existingMember) {
                    member.HP = existingMember.HP;
                    member.status = existingMember.status;
                }
            });
            availableMember.forEach(member => {
                let existingMember = teamMembers.find(m => m.id === member.id);
                if (existingMember) {
                    member.HP = existingMember.HP;
                    member.status = existingMember.status;
                }
            });

            // 根據角色 HP 更新情緒
            teamMembers.forEach(member => {
                if (member.HP === member.MaxHP) {
                    getEmotion(member.id, "fullHP");
                } else {
                    loseEmotion(member.id, "fullHP");
                }
            });

            // 檢查是否有角色死亡
            let deadMembers = presentMembers.filter(member => member.HP <= 0);
            if (deadMembers.length) {
                // 顯示死亡訊息（可顯示多人）
                let deadMemberNames = deadMembers.map(member => member.name).join("、");
                document.getElementById("team-action").textContent = texts.die(deadMemberNames); // 顯示死亡訊息

                // 遍歷死亡角色，添加情緒
                deadMembers.forEach(member => {
                    getEmotion(member.id, "knockedDown");
                });
            }

            // 檢查角色是否非死即逃
            if (presentMembers.length > 0) { // 檢查上場成員是否有人（如果沒人，有可能是全員逃走）
                let allMembersDead = presentMembers.every(member => member.HP <= 0); // 檢查上場成員是否都死亡
                if (allMembersDead) {
                    if (escapeMember.length > 0) { // 檢查逃跑成員是否有人
                        // 有人死亡，剩下的人都已逃走
                        battleResult = 3;
                        localStorage.setItem("battleResult", battleResult);
                        return; // 防止繼續執行後面的邏輯
                    }
                }
            }

            // 移除死亡角色，只保留HP大於0的角色
            presentMembers = presentMembers.filter(member => member.HP > 0); 
            availableMember = availableMember.filter(member => member.HP > 0); 
            localStorage.setItem("presentMembers", JSON.stringify(presentMembers));
            localStorage.setItem("availableMember", JSON.stringify(availableMember));
            
            //console.log("剩餘成員:", presentMembers);
            //console.log("可行動的成員", availableMember);
            generateTeam(); // 重新顯示隊伍

            // 檢查隊伍是否全滅
            if (presentMembers.length === 0) { // 檢查上場成員是否 0 人
                if (escapeMember.length === 0) { // 檢查逃跑成員是否 0 人
                    // 全員死亡
                    generateEnemy(); // 重新顯示敵人
                    defeated();
                } else {
                    // 全員逃走
                    battleResult = 2;
                    localStorage.setItem("battleResult", battleResult);
                    localStorage.removeItem("inEvent"); // 清除事件
                    endBattle();
                }
                return; // 防止繼續執行後面的邏輯
            }

            // 檢查敵人是否全滅
            if (enemies.every(enemy => enemy.HP <= 0)) {
                // 戰鬥勝利
                loot();
                battleResult = 1;
                localStorage.setItem("battleResult", battleResult);
                turnSwitch(); // 如果有觸發開關，將開關打開

                // 如果有指定戰勝後的對話
                const encounter = JSON.parse(localStorage.getItem("encounter")) || [];
                if (encounter && encounter.successKey) {
                    localStorage.setItem("currentKey", encounter.successKey);
                }

                // 添加戰勝的情緒
                presentMembers.forEach(member => {
                    getEmotion(member.id, "battleWin");
                })

                endBattle();
            }

            // 檢查是否搶劫敵人
            let robEnemy = localStorage.getItem("robEnemy") === "true"; 
            if (robEnemy) {
                // 搶劫敵人
                loot();
                battleResult = 4;
                localStorage.setItem("battleResult", battleResult);
                endBattle();
            }

            // 移除死亡的敵人
            enemies = enemies.filter(enemy => enemy.HP > 0); // 只保留HP大於0的敵人
            localStorage.setItem("enemies", JSON.stringify(enemies)); // 更新localStorage中的敵人資料
            generateEnemy(); // 重新顯示敵人
        }

        // 回合結束
        function endRound() {
            let teamMembers = JSON.parse(localStorage.getItem("teamMembers")) || [];

            // 移除標題和提示
            document.getElementById("situation").textContent = "";
            document.getElementById("battle-result").textContent = "";

            // 移除戰鬥訊息
            document.querySelectorAll(".battle-text").forEach(el => el.textContent = "");
            teamMembers.forEach(member => {
                localStorage.removeItem(`${member.id}-action-text`);
            });

            // 移除HP的紅字
            for (const el of document.querySelectorAll(".red-hp")) el.classList.remove("red-hp");
            localStorage.removeItem("redHP");

            // 角色的狀態減少持續回合
            teamMembers.forEach(member => {    
                member.status.forEach(s => {
                    s.duration --; // 減少持續回合
                });

                // 移除已結束的狀態
                member.status = member.status.filter(s => s.duration > 0);
            });

            // 儲存更新後的資料
            localStorage.setItem("teamMembers", JSON.stringify(teamMembers));


            // 判斷是否已經戰敗（因為戰勝的話，會直接在行動結束時跳轉，戰敗的話，要先讓玩家看一下發生什麼事，然後按下「回合結束」後才跳轉）
            battleResult = localStorage.getItem("battleResult");
            if (battleResult && (battleResult !== 1 || battleResult !== 2 || battleResult !== 4)) {
                localStorage.removeItem("inEvent"); // 清除事件
                endBattle();
                return;
            }
            
            // 檢查俘虜是否逃跑
                // 獲取俘虜、非俘虜成員的資料
                const prisoners = presentMembers.filter(member => member.type === "俘虜");
                const nonPrisoners = presentMembers.filter(member => member.type !== "俘虜");
   
                // 加總敏捷
                let teamDex = 0;
                nonPrisoners.forEach(member => {
                    teamDex += member.dex.total;
                });

                // 檢查每個俘虜
                prisoners.forEach(member => {
                    // 以雙方敏捷擲骰
                    let result = roll(member.dex.total, teamDex);
                    console.log(`俘虜敏捷: ${member.dex.total}, 隊伍總敏捷: ${teamDex}`);
                    console.log(`俘虜逃跑機率: ${(result.chance*100).toFixed(2)}%`);  // 顯示精確到小數點後2位

                    // 結果
                    if (result.success === true) {
                        // 俘虜逃跑
                        removepresentMembers(member.id); // 移出上場成員
                        removeCompanion(member.id); // 移出隊伍

                        // 顯示俘虜逃跑訊息（顯示在隊伍欄位，因為逃跑成功會清除角色欄位）
                        document.getElementById("team-action").textContent = texts.escapePrisoner(member.name);
                    }
                });

            // 讀取敵人資料
            let enemies = JSON.parse(localStorage.getItem("enemies")) || [];
            let enemyType = enemies.length > 0 ? enemies[0].type : 0;

            // 先將所有敵人加入可行動敵人
            let availableEnemies = [...enemies];  // 使用擴展語法確保actabeEnemies獨立於enemies

            // 每個敵人的狀態生效，並減少持續回合
            enemies.forEach(enemy => {
                // 先重置屬性
                ['str', 'dex', 'con', 'wis', 'cha', 'arm'].forEach(attr => {
                    enemy[attr].total -= enemy[attr][status] || 0; // 更新 total 屬性
                    enemy[attr][status] = 0; // 清除 status 屬性
                });
                return; 

                // 狀態效果
                enemy.status.forEach(s => {
                    // HP 增減
                    enemy.HP += s.HP || 0;

                    // 屬性增減
                    ['str', 'dex', 'con', 'wis', 'cha', 'arm'].forEach(attr => {
                      enemy[attr][status] += s[attr] || 0;  // 更新 status 屬性
                      enemy[attr].total += s[attr] || 0;    // 更新 total 屬性
                    });

                    // 無法行動
                    if (s.immobile) {
                        // 移出可行動敵人
                        const targetIndex = availableEnemies.findIndex(e => e.id === enemy.id);
                        if (targetIndex > -1) {
                            availableEnemies.splice(targetIndex, 1);
                        }

                        // 顯示狀態訊息
                        if (s.name === "倒地") {
                            localStorage.setItem(`${enemy.id}-action-text`, texts.prone);
                        } if (s.name === "石化") {
                            localStorage.setItem(`${enemy.id}-action-text`, texts.petrified);
                        }
                    }
                    
                    s.duration --; // 減少持續回合
                });

                // 移除已結束的狀態
                enemy.status = enemy.status.filter(s => s.duration > 0);
            });

            // 儲存更新後的敵人資料
            localStorage.setItem("enemies", JSON.stringify(enemies));
            localStorage.setItem("availableEnemies", JSON.stringify(availableEnemies));

            // 檢查敵人是否投降
                // 找到 str 最高的成員
                let maxStrMembers = [];
                let maxStr = -Infinity; // 設定初始值為負無限
                presentMembers.forEach(member => {
                    if (member.str.total > maxStr) { // 如果找到更高的 str，重置陣列，將該角色加入陣列
                        maxStr = member.str.total; //更新最高 str
                        maxStrMembers = [member];
                    }
                });

                // 敵人是否投降
                if (enemies.length === 1 && enemyType.includes("智慧") && maxStr > enemies[0].HP && !isTrue("enemySurrender")) {
                    // 如果只剩一個智慧敵人，且隊伍中最高力量 > 敵人 HP 時，且還沒投降過
                        
                    // 以雙方力量擲骰
                    let result = roll(maxStr, enemies[0].str.total);
                    console.log(`隊伍最高力量: ${maxStr}, 敵人力量: ${enemies[0].str.total}`);
                    console.log(`投降機率: ${(result.chance*100).toFixed(2)}%`);  // 顯示精確到小數點後2位

                    // 結果
                    if (result.success === true) {
                        turnSwitch("enemySurrender");
                        localStorage.setItem("npcId", enemies[0].id); // 儲存為交談對象
                        window.location.href = 'battleTalk.html'; // 敵人投降，跳轉到交談頁面
                        return;
                    }
                }

            // 如果敵人毫無防備，下回合恢復正常回合
            let situation = parseInt(localStorage.getItem("situation"));
            if (situation === 4) {
                localStorage.removeItem("situation"); // 清除遇敵方式
            }

            // --------------------------------
            // 新的回合開始
            // --------------------------------
            
            enemyFight(); // 敵人攻擊

            // 先將所有上場成員加入可行動成員
            let availableMember = [...presentMembers];  // 使用擴展語法確保availableMember獨立於presentMembers

            // 角色的狀態生效
            teamMembers = JSON.parse(localStorage.getItem("teamMembers")) || []; // 再次讀取以確保是最新資料
            teamMembers.forEach(member => {
                // 先重置屬性
                ["str", "dex", "con", "wis", "cha", "arm"].forEach(attr => {
                    member[attr].total = Object.entries(member[attr])
                        .filter(([key]) => key !== "total") // 過濾掉 "total"
                        .reduce((sum, [, val]) => sum + val, 0); // 累加數值
                });

                // 狀態效果
                member.status.forEach(s => {
                    // HP 增減
                    member.HP += s.HP || 0;

                    // 屬性增減
                    ["str", "dex", "con", "wis", "cha", "arm"].forEach(attr => {
                      member[attr].status += s[attr] || 0;  // 更新 status 屬性
                      member[attr].total += s[attr] || 0;    // 更新 total 屬性
                    });

                    // 無法行動
                    if (s.immobile) {
                        // 移出可行動成員
                        const targetIndex = availableMember.findIndex(e => e.id === member.id);
                        if (targetIndex > -1) {
                            availableMember.splice(targetIndex, 1);
                        }

                        // 顯示狀態訊息
                        if (s.name === "倒地") {
                            localStorage.setItem(`${member.id}-action-text`, texts.prone);
                        } if (s.name === "石化") {
                            localStorage.setItem(`${member.id}-action-text`, texts.petrified);
                        }
                    }
                });
            });

            // 儲存更新後的資料
            localStorage.setItem("teamMembers", JSON.stringify(teamMembers));
            localStorage.setItem("availableMember", JSON.stringify(availableMember));
            endAction();

            // 檢查雷納德是否路過幫忙
                isMember = teamMembers.some(m => m.name === "雷納德");
                const inEvent = localStorage.getItem("inEvent");

                if (!isMember && teamMembers.length < 4 && teamMembers.length > 0 && !inEvent && !isTrue("雷納德路過")) {
                    // 如果雷納德不在隊伍中，隊伍有空位，且不是在事件中，且今天還沒遇過雷納德，雷納德有機率加入
                    let randomValue = Math.random();
                    if (randomValue <= 0.05) { // 5% 機率加入
                        turnSwitch("雷納德路過");
                        localStorage.setItem("npcName", "雷納德");
                        showDialogue("雷納德幫忙");
                    }
                }

            // 重新顯示隊伍欄位及按鈕
            generateTeam(); 

            window.scrollTo({ top: 0, behavior: "smooth" }); // 跳到畫面上方
        }

        // 獲得金錢和戰利品
        function loot() {
            // 讀取所有敵人的資料
            let enemies = JSON.parse(localStorage.getItem("enemies")) || [];

            // 讀取初始敵人數量
            let enemyCount = parseInt(localStorage.getItem("enemyCount"));
                
            // 讀取玩家的金錢與物品
            let playerMoney = parseInt(localStorage.getItem("playerMoney")) || 0;
            let playerItems = JSON.parse(localStorage.getItem("playerItems")) || [];

            let totalMoney = 0;
            let totalLoot = [];

            // 計算金錢和戰利品
            enemies.forEach(enemy => {
                // 金錢
                if (enemy.money) {
                    totalMoney += enemy.money * enemyCount;
                    playerMoney += enemy.money * enemyCount;
                }
                // 戰利品（一般戰利品 + 武器 + 護甲）
                for (let i = 0; i < enemyCount; i++) {
                    // 戰利品
                    if (enemy.loot) {
                        if (Array.isArray(enemy.loot)) {
                            totalLoot = totalLoot.concat(enemy.loot); // 如果 enemy.loot 是陣列，將其所有物品加入 totalLoot
                        } else {
                            totalLoot.push(enemy.loot); // 如果只有一個物品，直接加入
                        }
                    }
                    // 武器和護甲
                    if (enemy.weapon.id) totalLoot.push(enemy.weapon.id);
                    if (enemy.armor.id) totalLoot.push(enemy.armor.id);
                }
            });

            // 更新玩家金錢與物品
            playerItems = playerItems.concat(totalLoot);
            localStorage.setItem("playerItems", JSON.stringify(playerItems));
            localStorage.setItem("playerMoney", playerMoney);

            // 統計戰利品的數量
            let lootCount = totalLoot.reduce((count, loot) => {
                count[loot] = (count[loot] || 0) + 1;
                return count;
            }, {});

            // 顯示獲得的金錢和戰利品
            let lootResult;

            // 獲得的金錢
            let moneyText = totalMoney > 0 ? `獲得 🪙 $${totalMoney}<br>` : "";

            // 獲得的戰利品
            let lootText = Object.keys(lootCount).map(loot => {
                //let item = itemDatabase.find(i => i.id === loot);
                let item = findItemData(loot); // 從資料庫查找物品
                return item ? `獲得 ${item.name} × ${lootCount[loot]}` : "";
            }).filter(text => text !== "").join("<br>");

            lootResult = moneyText + lootText;
            localStorage.setItem("lootResult", lootResult);
        }

        // 戰敗後的處理
        function defeated() {
            // 讀取第一個敵人的類型
            let enemies = JSON.parse(localStorage.getItem("enemies")) || [];
            let enemyType = enemies.length > 0 ? enemies[0].type : 0;

            // 讀取目前已逃跑的成員
            let escapeMember = JSON.parse(localStorage.getItem("escapeMember")) || [];
            let playerEscaped = escapeMember.some(member => member.id === "player");

            const encounter = JSON.parse(localStorage.getItem("encounter"));

            // 決定戰敗的情況
            if (enemyType.includes("類人") && !playerEscaped && !encounter) {
                // 如果是類人敵人、主角沒有逃走，也不是指定戰鬥，就隨機決定情況
                let randomValue = Math.random();

                if (randomValue < 1) { // 100% 被搶劫
                    battleResult = 6;
                } else { // 0% 被抓去當奴隸（尚未實裝）
                    battleResult = 7; 
                }                
                localStorage.setItem("battleResult", battleResult);

            } else { 
                // 否則單純被擊倒
                battleResult = 5;
                localStorage.setItem("battleResult", battleResult);
            }
            
            // 處理戰敗的情況
            if (battleResult === 6) { // 被搶劫的情況
                // 讀取主角金錢
                let playerMoney = parseInt(localStorage.getItem("playerMoney")) || 0;

                // 如果有錢，執行搶劫
                if (playerMoney > 0) {
                    // 隨機決定被搶走的金額（至少 1，最多一半）
                    let robbedMoney = Math.max(1, Math.floor(Math.random() * playerMoney * 0.5));
                    robbedMoney = Math.min(robbedMoney, playerMoney); // 確保不會超過擁有的金額

                    // 扣除金錢並儲存
                    playerMoney -= robbedMoney;
                    localStorage.setItem("playerMoney", playerMoney);
                    localStorage.setItem("robbedMoney", robbedMoney);

                } else {
                    // 沒有錢，改為普通擊倒
                    battleResult = 5;
                    localStorage.setItem("battleResult", battleResult);
                }

            } else if (battleResult === 7) { // 成為奴隸的情況（尚未實裝）

            }

            // 檢查有沒有包裹，隨機損壞一件
                let playerItems = JSON.parse(localStorage.getItem("playerItems")) || [];
                let packages = playerItems.filter(item => item === "package01" || item === "package02");

                if (packages.length > 0) {
                    // 隨機選擇一件包裹
                    let randomPackage = packages[Math.floor(Math.random() * packages.length)];

                    // 根據這個包裹的id替換為損壞包裹
                    playerItems = playerItems.map(item => {
                        if (item === randomPackage) {
                            return randomPackage === "package01" ? "package01_damaged" : "package02_damaged"; // 替換為損壞版本
                        }
                        return item; // 保留其他包裹不變
                    });

                    // 更新 localStorage
                    localStorage.setItem("playerItems", JSON.stringify(playerItems));
                }

            // 如果有指定戰敗後的對話
            if (encounter && encounter.failKey) {
                localStorage.setItem("currentKey", encounter.failKey);
            } else {
                localStorage.removeItem("inEvent"); // 清除事件
            }
                
            localStorage.removeItem("helpVictim"); // 清除「幫助平民」開關

            // 隨機決定重生的情況
            let respawn;
            let randomValue = Math.random();
            if (randomValue < 0.5) { // 50% 原地重生
                respawn = 1; 
            } else { // 50% 被送回城鎮
                respawn = 2; 
            }

            // 如果在事件中，只會原地重生
            const inEvent = localStorage.getItem("inEvent");
            if (inEvent) {
                respawn = 1; 
            }
            
            // 如果指定敵人是守衛，就會被逮捕
            if (encounter && encounter.enemyName === "守衛") {
                respawn = 3; // 在監獄重生
            }

            // 儲存重生的情況
            localStorage.setItem("respawn", respawn);
        }

        // 戰鬥結束
        function endBattle() {  
            window.location.href = 'battleResult.html'; // 跳轉到戰鬥結果頁面
        }

        // 幫手加入
        function helperJoin() {
            // 加入隊伍
            const npcName = localStorage.getItem("npcName");
            let companion = mercenaries.find(comp => comp.name === npcName);
            addCompanion(companion);

            // 找到隊中的id
            const teamMembers = JSON.parse(localStorage.getItem("teamMembers")) || [];
            let member = teamMembers.find(m => m.name === npcName);

            // 加入上場成員、可行動成員
            let presentMembers = JSON.parse(localStorage.getItem("presentMembers")) || [];
            let availableMember = JSON.parse(localStorage.getItem("availableMember")) || [];
            presentMembers.push(member);
            availableMember.push(member);
            localStorage.setItem("presentMembers", JSON.stringify(presentMembers));
            localStorage.setItem("availableMember", JSON.stringify(availableMember));

            generateTeam();
        }

        // 附加狀態
        function giveStatus(weapon, target) {
            if (weapon && weapon.addStatus) {
                // 用武器的附加機率擲骰（不用過屬性檢定）
                let success = Math.random() <= weapon.addChance;
                console.log(`狀態附加成功率: ${(weapon.addChance*100)}%`);
                
                // 附加成功
                if (success) {
                    let status = statusData.find(sta => sta.name === weapon.addStatus);
                    target.status.push(status);
                    return status.name;
                }
            }
        }

    </script>

</body>
</html>
