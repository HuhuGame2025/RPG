<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>戰鬥</title>
    <link rel="stylesheet" href="style.css">
    <style>
        body {
        }
    </style>
</head>
<body>
    <!-- 按鈕列 -->
    <div class="button-bar" id="buttonBar">
        <a href="menu/character.html">🎭<span>角色</span></a>
        <a href="menu/quest.html">📜<span>任務</span></a>
        <a href="menu/inventory.html">💰<span>物品</span></a>
        <a href="menu/option.html">⚙️<span>選項</span></a>
    </div>

    <!-- 主要內容區域 -->
    <div id="main" class="main-content">
        <h2 id="situation"></h2>
        <p id="battle-result"></p>
        <p id="respawn-result"></p>

        <div id="battle-content">
            <!-- 敵人列表 -->
            <div id="enemy-list"></div>
            <hr>

            <!-- 提示 -->
            <p class="note" id="note"></p>
            <p id="soul-count"></p>

            <!-- 隊伍列表 -->
            <div id="member-list"></div>

            <!-- 隊伍按鈕 -->
            <p id="team-action" class="battle-text"></p>
            <div class="menu">
                <div class="menu team-btn">
                    <button onclick="selectAttacker('team')">⚔️聯手攻擊</span></button>
                    <button onclick="escape('team')">🏃一起逃跑</span></button>
                </div>
                <br>
                <button onclick="endRound()">結束回合</button>
            </div>
        </div>
    </div>

    <!-- 對話區域 -->
    <div id="dialogue" class="main-content"></div>

    <script src="script.js"></script>
    <script>

        // 顯示文本
        const texts = {
            noTarget: "請先選擇一個敵人為目標",
            noAttacker: "請選擇由誰發動攻擊",
            fightWin: (damage) => `擊中敵人(${damage})！`,
            fightWinWithStatus: (damage, status) => `擊中敵人(${damage})，使他${status}了！`,
            fightLose: "打算攻擊，但被躲開了",
            fightFlyingEnemy: "無法觸及空中的敵人",
            killEnemy: (damage) => `打敗了敵人(${damage})！`,
            die: (deadMembers) => `${deadMembers}倒下了！`,
            teamFightWin: (damage) => `你們聯手，對敵人造成了重創！(${damage})`,
            teamFightLose: "敵人非常頑強，避開了所有的攻擊",
            teamKillEnemy: (damage) => `你們聯手打敗敵人(${damage})！`,
            escapeSuccess: (name) => `${name}逃走了`,
            escapeFail: (name) => `敵人阻擋了${name}的去路！`,
            teamEscapeFail: (name) => `${name}跑不過敵人，你們只好停下來！`,
            enemyWin: (name, damage) => `擊中${name}(${damage})！`,
            enemyWinWithStatus: (name, damage, status) => `擊中${name}(${damage})，使他${status}了！`,
            enemyLose: (name) => `打算攻擊${name}，但被躲開了`,
            enemyKill: (name, damage) => `打敗了${name}(${damage})！`,
            enemyFly: "飛上了高空",
            safe: "順利前進",
            battle: "敵人出現了！",
            surprise: "遭到偷襲了！",
            cannotTalk: "敵人無法理解你說的話。",
            escapePrisoner: (name) => `${name}趁你在對付敵人時逃走了！`,
            demonAttacked: "燃燒了起來",
            bleeding: "流血了",
            prone: "倒地了",
            unactable: "正在起身",
            //trap: "觸發陷阱！",
            //enemyComing: "敵人正在趕來的路上，最好快點離開",
        };

        // 畫面載入時
        window.onload = function() {
            getSituation(); // 讀取並執行遇敵方式
            loadBackground(); // 讀取背景
            npcPreferences(); // NPC偏好設定
        };

        // 對話資料庫
        const dialogueData = {
            "雷納德": {
                "雷納德幫忙": {
                    npc: "npc",
                    text: "沒事吧？你需要幫忙嗎？",
                    choices: [
                        { text: "拜託了", next: "", action: "(helperJoin(), removeDialogue(), getSituation())" },
                        { text: "不用幫忙", next: "", action: "(removeDialogue(), getSituation())" },
                    ]
                },
            },
        }

        let enemy = {}; // 當前敵人
        let escapeMember= []; // 逃跑成員

        // 讀取並執行遇敵方式
        function getSituation() {
            let situation = parseInt(localStorage.getItem("situation"));
            //situation = 3; // 測試用

            let enemies = JSON.parse(localStorage.getItem("enemies")) || [];

            if (situation === 2 || situation === 7) {
                // 顯示敵人準備戰鬥的描述
                enemies.forEach(enemy => {
                    //document.getElementById(`${enemies.id}-action`).textContent = enemy.actionBattle; 
                    localStorage.setItem(`${enemy.id}-action-text`, enemy.actionBattle);
                });

                document.getElementById("situation").textContent = texts.battle; // 顯示遇敵的訊息
                localStorage.removeItem("situation"); // 清除遇敵方式
                console.log("一般遇敵（我方先攻）");

            } else if (situation === 3) {
                document.getElementById("situation").textContent = texts.surprise; // 顯示被偷襲的訊
                localStorage.removeItem("situation"); // 清除遇敵方式
                console.log("被偷襲（敵人先攻）");

                startBattle() // 開始戰鬥
                enemyFight(); // 敵人攻擊

            } else if (situation === 4) {
                // 顯示敵人沒有防備的描述
                enemies.forEach(enemy => {
                    //document.getElementById(`${enemies.id}-action`).textContent = enemy.action; 
                    localStorage.setItem(`${enemy.id}-action-text`, enemy.action);
                });
                console.log("發現無防備的敵人（我方第一回合攻擊、逃跑100%成功）");
            }
            startBattle() // 開始戰鬥
        }

        // 開始戰鬥
        function startBattle() {
            loadPartyData(); // 讀取隊伍資料
            //generateTeam(); // 顯示上場成員欄位及按鈕（已包含在endAction）
            //generateEnemy(); // 顯示敵人（已包含在endAction）
            endAction(); // 每次載入時跑一次，以防有東西還原
        }

        // 顯示上場成員
        function generateTeam() {
            presentMembers = JSON.parse(localStorage.getItem("presentMembers")) || [];
            actableMembers = JSON.parse(localStorage.getItem("actableMembers")) || [];

            const menu = document.getElementById("member-list");
            menu.innerHTML = "";  // 清空選單內容

            // 創建每個成員的資料
            presentMembers.forEach(member => {
                const characterDiv = document.createElement("div");

                let isActable = actableMembers.some(m => m.id === member.id);
                let isPlayer = member.id === "player";

                // 取得狀態圖示
                const statusIcon = member.status.map(s => s.icon).join("");

                characterDiv.innerHTML = `
                    <div id="${member.id}" class="background">
                        <div class="column-container item">
                            <div class="column-name">
                                <h4>${member.name}</h4>
                                <h4 class="hp"><span id="${member.id}-HP">${member.HP}</span> / ${member.MaxHP}</h4>
                                ${statusIcon ? `
                                    <span class="status-icon">${statusIcon}</span>
                                ` : "" }
                            </div>
                            <div class="column">
                                <span id="${member.id}-action" class="battle-text"></span>
                                ${isActable ? `
                                    <div class="row-buttons ${member.id}-btn">
                                        <button onclick="selectAttacker('${member.id}')">⚔️<br><span class="small">攻擊</span></button>
                                        <button onclick="escape('${member.id}')">🏃<br><span class="small">逃跑</span></button>
                                        ${isPlayer ? `
                                            <button onclick="talk()">💬<br><span class="small">交談</span></button>
                                        ` : "" }
                                    </div>
                                ` : "" }
                            </div>
                        </div>
                    </div>
                `;
                menu.appendChild(characterDiv);

                // 顯示訊息
                const message = localStorage.getItem(`${member.id}-action-text`) || "";
                document.getElementById(`${member.id}-action`).textContent = message;

                // HP改為紅字
                const redHP = JSON.parse(localStorage.getItem("redHP")) || [];
                redHP.forEach(HP => {
                    if (document.getElementById(HP)) {
                        document.getElementById(HP).classList.add("red-hp");
                    }
                });
            });

            // 檢查是否顯示隊伍按鈕
            if (actableMembers.length < 2) {
                // 如果可行動的隊員不到 2 個，隱藏隊伍按鈕
                document.querySelectorAll('.team-btn button').forEach(button => {
                    button.style.display = "none";
                });
            } else {
                // 否則顯示
                document.querySelectorAll('.team-btn button').forEach(button => {
                    button.style.display = "block";
                });
            }

            // 如果物品中有可用的紅寶石，就顯示已獻祭的數量
            const playerItems = JSON.parse(localStorage.getItem("playerItems")) || [];
            const ruby = playerItems.find(i => i === "specialItem14");
            if (ruby) {
                const soulCount = parseInt(localStorage.getItem("soulCount"));
                document.getElementById('soul-count').textContent = "💀 " + soulCount;
            }
            
            //console.log("可行動的成員", actableMembers);
        }

        // 顯示敵人
        function generateEnemy() {
            let enemies = JSON.parse(localStorage.getItem("enemies")) || [];

            const menu = document.getElementById("enemy-list");
            menu.innerHTML = "";  // 清空選單內容

            // 創建每個敵人的資料
            enemies.forEach((enemy, index) => {
                const characterDiv = document.createElement("div");

                // 取得狀態圖示
                const statusIcon = enemy.status.map(s => s.icon).join("");

                characterDiv.innerHTML = `
                    <div id="${enemy.id}">
                        <button id="${enemy.id}-btn" onclick="selectTarget('${enemy.id}', this)">
                            <div class="column-container">
                                <div class="column-name">
                                    <h4>${enemy.adj}${enemy.name}</span></h4>
                                    <h4 class="hp"><span id="${enemy.id}-HP">${enemy.HP}</span> / ${enemy.MaxHP}</h4>
                                    ${statusIcon ? `
                                        <span class="status-icon">${statusIcon}</span>
                                    ` : "" }
                                </div>
                                <div class="column">
                                    <span id="${enemy.id}-action" class="battle-text"></span>
                                </div>
                            </div>
                        </button>
                    </div>
                `;
                menu.appendChild(characterDiv);

                // 顯示訊息
                const message = localStorage.getItem(`${enemy.id}-action-text`) || "";
                document.getElementById(`${enemy.id}-action`).textContent = message;

                // HP改為紅字
                const redHP = JSON.parse(localStorage.getItem("redHP")) || [];
                redHP.forEach(HP => {
                    if (document.getElementById(HP)) {
                        document.getElementById(HP).classList.add("red-hp");
                    }
                });
            });

            console.log("敵人:", enemies);
        }

        let selectedAttacker = null; // 記錄攻擊者
        let selectedTarget = null; // 記錄目標敵人

        // 選擇攻擊者（角色或同伴）
        function selectAttacker(attackerId) {
            // 如果已選擇目標，就進入戰鬥
            if (selectedTarget) {
                selectedAttacker = attackerId;
                checkAndExecuteFight();
            // 如果還沒選擇目標，就顯示提示
            } else {
                document.getElementById("note").textContent = texts.noTarget;
            }
        }

        // 選擇目標敵人
        function selectTarget(targetId, button) {
            // 移除所有目標按鈕的 selected class
            document.querySelectorAll("button[id^='enemy']").forEach(btn => {
                btn.classList.remove("selected");
            });

            // 為當前選中的按鈕加上 selected class
            button.classList.add("selected");

            // 顯示「選擇攻擊者」的提示
            document.getElementById("note").textContent = texts.noAttacker;

            // 將選擇的敵人設為目標
            selectedTarget = targetId;
        }

        // 檢查是否已選擇攻擊者和目標，然後執行攻擊
        function checkAndExecuteFight() {
            if (selectedAttacker && selectedTarget) {
                // 執行攻擊邏輯
                fight(selectedAttacker, selectedTarget);

                // 重置選擇，以便下一次攻擊
                selectedAttacker = null;
                // selectedTarget = null;
            }
        }

        // 攻擊邏輯
        function fight(attackerId, target) {            
            // 獲取敵人資料
            let enemies = JSON.parse(localStorage.getItem("enemies")) || [];
            let targetEnemy = enemies.find(e => e.id === target);
            let isFly = Object.values(targetEnemy.status).some(s => s.name === "飛行");

            // 讀取可行動成員的資料
            let actableMembers = JSON.parse(localStorage.getItem("actableMembers")) || [];
          
            // 確認攻擊者人數
            let attacker = [];
            if (attackerId === "team") {
                // 聯手攻擊，計入所有可行動成員
                attacker = actableMembers;
            } else {
                // 單獨攻擊，找到攻擊者
                singleAttacker  = actableMembers.find(comp => comp.id === attackerId);
                attacker = [singleAttacker]; // 包成陣列
            }

            // 如果敵人飛行中，只計入遠程武器
            if (isFly) {
                attacker = attacker.filter(member => 
                    member.weapon && member.weapon.category === "遠程",
                );
            }

            // 取得攻擊者資料
            let attackerName = [], attackerDex = 0, attackerStr = 0, attackerWeapon = [];
            attacker.forEach(member => {
                attackerName.push(member.name);
                attackerDex += member.dex.total; // 我方總敏捷
                attackerStr += member.str.total; // 我方總力量
                attackerWeapon.push(member.weapon); // 我方武器
            });

            // 以雙方敏捷擲骰
            let result = roll(attackerDex, targetEnemy.dex.total);

            // 檢查是否有例外
            let situation = parseInt(localStorage.getItem("situation"));
            let isPlant = targetEnemy.type.includes("植物");
            let isProne = Object.values(targetEnemy.status).some(s => s.name === "倒地");

            if (situation === 4 || isProne || isPlant) { 
                // 如果敵人無防備、目標倒地、目標是植物，自動成功
                result = { success: true, chance: 1 };
            }
            console.log(`攻擊者: ${attackerName}, 敏捷: ${attackerDex}, 目標: ${target}, 目標敏捷: ${targetEnemy.dex.total}`);
            console.log(`攻擊命中率: ${(result.chance*100).toFixed(2)}%`);  // 顯示精確到小數點後2位

            // 攻擊結果
            if (result.success === true) {
                // 攻擊成功，對目標造成傷害
                let damage = Math.max(attackerStr - targetEnemy.arm.total, 0); // 傷害 = 我方力量總和 - 敵人護甲
                targetEnemy.HP = Math.max(targetEnemy.HP - damage, 0); // HP 減少，不會低於0
                document.getElementById(`${target}-HP`).textContent = targetEnemy.HP;

                // HP 變為紅字（只有一個）
                //for (const el of document.querySelectorAll(".red-hp")) el.classList.remove("red-hp"); // 先移除之前的紅字
                //document.getElementById(`${target}-HP`).classList.add("red-hp");
                let redHP = [];
                redHP.push(`${target}-HP`);
                localStorage.setItem("redHP", JSON.stringify(redHP));

                // 檢查敵人是否死亡
                if (targetEnemy.HP <= 0) {
                    // 敵人死亡
                    if (attackerId === "team") {
                        // 顯示聯手擊殺訊息（在隊伍的欄位）
                        document.getElementById("team-action").textContent = texts.teamKillEnemy(damage);
                    } else {
                        // 顯示單獨擊殺訊息（在攻擊者的欄位）
                        localStorage.setItem(`${attackerId}-action-text`, texts.killEnemy(damage));
                    }
                    // 清除目標
                    selectedTarget = null;

                } else {
                    // 敵人活著
                    if (attackerId === "team") {
                        // 顯示聯手攻擊成功訊息（在隊伍的欄位）
                        localStorage.setItem(`${attackerId}-action-text`, texts.teamFightWin(damage));

                    } else {
                        // 顯示單獨攻擊成功訊息（在攻擊者的欄位）
                        localStorage.setItem(`${attackerId}-action-text`, texts.fightWin(damage));
                    }

                    // 檢查是否附加狀態
                    attackerWeapon.forEach(weapon => {
                        // 如果武器有附加狀態，用武器的力量擲骰
                        let status = statusData[weapon.category];
                        if (status && roll(weapon.str * status.multiplier).success) {
                            // 添加狀態
                            targetEnemy.status.push(status);

                            // 顯示附加狀態的訊息
                            localStorage.setItem(`${attackerId}-action-text`, texts.fightWinWithStatus(damage, status.name));
                            console.log("造成" + status.name);
                        }
                    });

                };

                localStorage.setItem("enemies", JSON.stringify(enemies));  // 儲存更新後的敵人資料

            } else {
                // 攻擊失敗
                if (isFly && hitChance === 0) {
                    // 如果目標在飛行，且沒有遠程武器
                    if (attackerId === "team") {
                        // 顯示聯手攻擊無法觸及訊息（在隊伍的欄位）
                        document.getElementById("team-action").textContent = texts.fightFlyingEnemy;
                    } else {
                        // 顯示單獨攻擊無法觸及訊息（在攻擊者的欄位）
                        localStorage.setItem(`${attackerId}-action-text`, texts.fightFlyingEnemy);
                    }
                    
                } else {
                    // 預設情況
                    if (attackerId === "team") {
                        // 顯示聯手攻擊失敗訊息（在隊伍的欄位）
                        document.getElementById("team-action").textContent = texts.teamFightLose;
                    } else {
                        // 顯示單獨攻擊失敗訊息（在攻擊者的欄位）
                        localStorage.setItem(`${attackerId}-action-text`, texts.fightLose);
                    }
                }
            }

            // 攻擊結束後
            if (attackerId === "team") {
                // 聯手攻擊，隱藏可行動成員的攻擊、逃跑按鈕
                actableMembers.forEach(member => {
                    document.querySelectorAll(`.${member.id}-btn button`).forEach(button => {
                        button.style.display = "none";
                    });

                    removeactableMembers(member.id); // 將攻擊者移出可行動成員
                });

                // 隱藏聯手攻擊、一起逃跑按鈕
                document.querySelectorAll('.team-btn button').forEach(button => {
                    button.style.display = "none";
                });
            } else {
                // 單獨攻擊，隱藏攻擊者的攻擊、逃跑按鈕
                document.querySelectorAll(`.${attackerId}-btn button`).forEach(button => {
                    button.style.display = "none";
                });

                removeactableMembers(attackerId); // 將攻擊者移出可行動成員
            }

            endAction();
        }

        // 逃跑邏輯
        function escape(escaper) {
            let presentMembers = JSON.parse(localStorage.getItem("presentMembers")) || [];
            let actableMembers = JSON.parse(localStorage.getItem("actableMembers")) || [];

            let escaperName;
            let escaperDex = 0; // 我方總敏捷
            let minDexMembers = [];
          
            if (escaper === "team") {
                // 一起逃跑，找到 dex 最低的成員資料
                let minDex = Infinity; // 設定初始值為無限大
                actableMembers.forEach(member => {
                    if (member.dex.total < minDex) { // 如果找到更低的 dex，重置陣列，將該角色加入陣列
                        minDex = member.dex.total; //更新最低 dex
                        minDexMembers = [member];
                    } else if (member.dex.total === minDex) {
                        minDexMembers.push(member); // 如果dex相同，將該角色加入陣列
                    }
                });
                escaperName = "一起";
                escaperDex = minDex;
            } else {
                // 單獨逃跑，找到逃跑者的資料
                let member = actableMembers.find(comp => comp.id === escaper);
                escaperName = member.name;
                escaperDex = member.dex.total;
            }

            // 讀取第一個敵人的資料
            let enemies = JSON.parse(localStorage.getItem("enemies")) || [];
            let enemyDex = enemies.length > 0 ? enemies[0].dex.total : 0; // 取第一個敵人的敏捷
            let enemyType = enemies.length > 0 ? enemies[0].type : ""; // 取第一個敵人的類型
            let actableEnemies = JSON.parse(localStorage.getItem("actableEnemies")) || [];

            // 以雙方敏捷擲骰
            let result = roll(escaperDex, enemyDex);

            // 檢查是否有例外
            let situation = parseInt(localStorage.getItem("situation"));
            let isPlant = enemyType.includes("植物");
            let allFly = enemies.filter(s => !s.status.some(s => s.name === "飛行")).length === 0;

            if (situation === 4 || isPlant ||  allFly) { 
                // 如果敵人無防備、敵人是植物、敵人全倒地、敵人全飛行中，自動成功
                result = { success: true, chance: 1 };
            } else if (escaper !== "team" && presentMembers.length > actableEnemies.length) {
                // 如果單獨逃跑時，上場成員比可行動敵人多，敵人就無法分心追趕，自動成功
                result = { success: true, chance: 1 };
            }
            console.log(`逃跑者: ${escaperName}, 敏捷: ${escaperDex}, 敵人敏捷: ${enemyDex}`);
            console.log(`逃跑成功率: ${(result.chance*100).toFixed(2)}%`);

            // 逃跑結果
            if (result.success === true) {
                // 逃跑成功
                if (escaper === "team") {
                    actableMembers.forEach(member => {
                        removepresentMembers(member.id); // 移出上場成員
                        addEscapeMember(member.id); // 加入逃跑成員
                    });

                    // 取得所有逃跑成員的名字並用頓號「、」分隔
                    let escapers = actableMembers.map(member => member.name).join("、");

                    // 顯示一起逃跑成功訊息
                    document.getElementById("team-action").textContent = texts.escapeSuccess(escapers);
                } else {
                    removepresentMembers(escaper); // 移出上場成員
                    addEscapeMember(escaper); // 加入逃跑成員

                    // 顯示單獨逃跑成功訊息（顯示在隊伍欄位，因為逃跑成功會清除角色欄位）
                    document.getElementById("team-action").textContent = texts.escapeSuccess(escaperName);
                }

            } else {
                // 逃跑失敗
                if (escaper === "team") {
                    // 取得敏捷最低者的名字並用頓號「、」分隔
                    escapers = minDexMembers.map(member => member.name).join("、");

                    // 顯示一起逃跑失敗訊息
                    document.getElementById("team-action").textContent = texts.teamEscapeFail(escapers);               
                } else {
                    // 顯示單獨逃跑失敗訊息（在逃跑者的欄位）
                    //document.getElementById(`${escaper}-action`).textContent = texts.escapeFail(escaperName);
                    localStorage.setItem(`${escaper}-action-text`, texts.escapeFail(escaperName));
                }
            }

            // 逃跑結束後
            if (escaper === "team") {
                // 一起逃跑，隱藏可行動成員的攻擊、逃跑按鈕
                actableMembers.forEach(member => {
                    document.querySelectorAll(`.${member.id}-btn button`).forEach(button => {
                        button.style.display = "none";
                    });
                    //localStorage.removeItem(`${member.id}-btn-show`); // 隱藏按鈕

                    removeactableMembers(member.id); // 將攻擊者移出可行動成員
                });

                // 隱藏聯手攻擊和一起逃跑按鈕
                document.querySelectorAll('.team-btn button').forEach(button => {
                    button.style.display = "none";
                });
            } else {
                // 單獨攻擊，隱藏逃跑者的攻擊、逃跑按鈕
                document.querySelectorAll(`.${escaper}-btn button`).forEach(button => {
                    button.style.display = "none";
                });
                //localStorage.removeItem(`${escaper}-btn-show`);  // 隱藏按鈕

                removeactableMembers(escaper); // 將逃跑者移出可行動成員
            }

            endAction();
        }

        // 交談
        function talk() {
            // 讀取所有敵人的資料
            let enemies = JSON.parse(localStorage.getItem("enemies")) || [];

            let enemyType = enemies.length > 0 ? enemies[0].type : ""; // 取第一個敵人的類型
            
            // 檢查敵人類型是不是智慧
            if (enemyType.includes("智慧")) {
                if (selectedTarget) {
                    // 如果已選擇目標，就進入交談
                    localStorage.setItem("npcId", selectedTarget); // 儲存交談對象

                    // 隱藏主角的攻擊、逃跑按鈕
                    document.querySelectorAll("player-btn button").forEach(button => {
                        button.style.display = "none";
                    });
                    //localStorage.removeItem("player-btn-show"); // 隱藏按鈕
                    removeactableMembers("player"); // 將主角移出可行動成員
                    
                    window.location.href = 'battleTalk.html'; // 跳轉到交談頁面

                } else {
                    // 如果還沒選擇目標，就顯示提示
                    document.getElementById("note").textContent = texts.noTarget;
                }
            } else {
                // 如果不是智慧，就顯示無法對話的提示
                document.getElementById("note").textContent = texts.cannotTalk;
            }
        }

        // 敵人攻擊邏輯
        function enemyFight() {
            // 讀取同伴資料
            let teamMembers = JSON.parse(localStorage.getItem("teamMembers"))

            // 讀取第一個敵人的資料
            let enemies = JSON.parse(localStorage.getItem("enemies")) || [];
            let enemyType = enemies.length > 0 ? enemies[0].type : 0;
            let enemyDex = enemies[0].dex.total; 
            let enemyStr = enemies[0].str.total;

            // 讀取可行動敵人
            let actableEnemies = JSON.parse(localStorage.getItem("actableEnemies"))

            // 每個敵人行動
            enemies.forEach(enemy => {
                // 無法行動則中止
                let isActable = actableEnemies.some(e => e.id === enemy.id);
                if (!isActable) return;

                // 若上場成員沒人則中止（戰敗時讓玩家看情況）
                if (presentMembers.length === 0) return;

                // 如果是飛行類敵人，有 20% 機率飛行
                if (enemyType.includes("飛行")) {
                    if (Math.random() <= 0.2) {
                        enemy.status.push(statusData["飛行"]);
                        localStorage.setItem("enemies", JSON.stringify(enemies));

                        // 顯示飛行的訊息
                        //document.getElementById(`${enemy.id}-action`).textContent = texts.enemyFly;
                        localStorage.setItem(`${enemy.id}-action-text`, texts.enemyFly);
                        return;
                    }
                }

                // 隨機選擇一個目標
                let randomIndex = Math.floor(Math.random() * presentMembers.length);
                let hurtMember = teamMembers.find(m => m.id === presentMembers[randomIndex].id);

                // 計算敵人命中率
                let hitChance;
                let isProne = Object.values(hurtMember.status).some(s => s.name === "倒地");

                if (situation === 4 || isProne) { 
                    // 如果目標倒地，命中率100%
                    hitChance = 1;
                } else {
                    // 預設情況，以雙方敏捷計算命中率
                    hitChance = enemyDex / (enemyDex + hurtMember.dex.total);
                }

                let randomValue = Math.random(); // 產生 0~1 的隨機小數
                // 檢查命中率
                console.log(`攻擊者: ${enemy.name}, 敏捷: ${enemyDex}, 目標: ${hurtMember.name}, 目標敏捷: ${hurtMember.dex.total}`);
                console.log(`計算的敵人命中率: ${(hitChance*100).toFixed(2)}%`);  // 顯示精確到小數點後2位

                // 攻擊結果
                if (randomValue < hitChance) {
                    // 敵人攻擊成功，對角色造成傷害
                    let damage = Math.max(enemyStr - hurtMember.arm.total, 0); // 傷害 = 攻擊者的力量 - 目標的護甲
                    hurtMember.HP = Math.max(hurtMember.HP - damage, 0); // HP減少，不會低於0
                    document.getElementById(`${hurtMember.id}-HP`).textContent = hurtMember.HP;

                    // HP變為紅字（不移除之前的紅字，可以同時有多個紅字）
                    //document.getElementById(`${hurtMember.id}-HP`).classList.add("red-hp");
                    let redHP = JSON.parse(localStorage.getItem("redHP")) || [];
                    redHP.push(`${hurtMember.id}-HP`);
                    localStorage.setItem("redHP", JSON.stringify(redHP));
                    
                    // 判斷角色是否死亡
                    if (hurtMember.HP <= 0) {
                        // 如果角色死亡，顯示被擊殺訊息（在敵人的欄位）
                        //document.getElementById(`${enemy.id}-action`).textContent = texts.enemyKill(hurtMember.name, damage);
                        localStorage.setItem(`${enemy.id}-action-text`, texts.enemyKill(hurtMember.name, damage));

                    } else {
                        // 如果角色活著，顯示被攻擊訊息（在敵人的欄位）
                        //document.getElementById(`${enemy.id}-action`).textContent = texts.enemyWin(hurtMember.name, damage);
                        localStorage.setItem(`${enemy.id}-action-text`, texts.enemyWin(hurtMember.name, damage));

                        // 檢查是否附加狀態
                            // 如果武器有附加狀態，用武器的力量擲骰
                            let status = statusData[enemy.weapon.category];
                            if (status && roll(enemy.weapon.str * status.multiplier).success) {
                                // 添加狀態
                                hurtMember.status.push(status);

                                // 顯示附加狀態的訊息（在敵人的欄位）
                                localStorage.setItem(`${enemy.id}-action-text`, texts.enemyWinWithStatus(hurtMember.name, damage, status.name));
                                console.log("造成" + status.name);
                            }
                    }
                    //console.log(teamMembers);
                    localStorage.setItem("teamMembers", JSON.stringify(teamMembers));

                } else {
                    // 敵人攻擊失敗，顯示訊息（在敵人的欄位）
                    //document.getElementById(`${enemy.id}-action`).textContent = texts.enemyLose(hurtMember.name);
                    localStorage.setItem(`${enemy.id}-action-text`, texts.enemyLose(hurtMember.name));
                }
                endAction();
            })
        }

        // 角色離開上場成員
        function removepresentMembers(removeMember) {
            let index = presentMembers.findIndex(member => member.id === removeMember);

            if (index !== -1) {
                let removedMember = presentMembers.splice(index, 1)[0]; // 移除並返回該成員
                console.log(`${removedMember.name} 離開了隊伍`);
            } else {
                console.warn(`無效的同伴: ${removeMember}`);
            }
            localStorage.setItem("presentMembers", JSON.stringify(presentMembers));
            console.log("剩餘成員：", presentMembers.map(m => m.name));
        }

        // 角色離開可行動隊伍
        function removeactableMembers(removeMember) {
            let index = actableMembers.findIndex(member => member.id === removeMember);

            if (index !== -1) {
                let removedMember = actableMembers.splice(index, 1)[0]; // 移除並返回該成員
                //console.log(`${removedMember.name} 離開了隊伍`);
            } else {
                //console.warn(`無效的同伴: ${removeMember}`);
            }
            localStorage.setItem("actableMembers", JSON.stringify(actableMembers));
            //console.log("還沒行動過的成員：", actableMembers.map(m => m.name));
        }

        // 角色加入逃跑成員
        function addEscapeMember(escaper) {
            // 讀取目前已逃跑的成員
            let escapeMember = JSON.parse(localStorage.getItem("escapeMember")) || [];
            
            // 讀取可行動成員的資料
            let actableMembers = JSON.parse(localStorage.getItem("actableMembers")) || [];
            
            // 找到逃跑者的名字
            let member = actableMembers.find(comp => comp.id === escaper);

            //加入逃跑成員
            escapeMember.push(member);

            localStorage.setItem("escapeMember", JSON.stringify(escapeMember));
            console.log("已逃跑成員：", escapeMember.map(m => m.name));
        }

        // 行動結束（敵我通用）
        function endAction() {  
            // 移除提示
            document.getElementById("note").textContent = "";
            document.getElementById("battle-result").textContent = "";

            let battleResult = 0;
            let respawn = 0;

            // 讀取所有敵人資料
            let enemies = JSON.parse(localStorage.getItem("enemies")) || [];

            // 如果殺死守衛，通緝等級上升，名聲下降
            enemies.forEach(enemy => {
                if (enemy.name === "守衛" && enemy.HP === 0) {
                    addWantedLevel(5);
                    addPlayerFame(-5);
                }
            });

            // 計算獻祭的靈魂數量
            enemies.forEach(enemy => {
                if (enemy.HP === 0) {
                    let soulCount = parseInt(localStorage.getItem("soulCount"));
                    soulCount ++; // 靈魂增加
                    localStorage.setItem("soulCount", soulCount);
                }
            });

            // 檢查是否執行惡魔攻擊
            const demonAttack = localStorage.getItem("demonAttack");
            if (demonAttack) {
                enemies.forEach(enemy => {
                    let damage = 10; // 傷害 = 10
                    enemy.HP = Math.max(enemy.HP - damage, 0); // HP 減少，不會低於0

                    // HP變為紅字
                    //document.getElementById(`${enemy.id}-HP`).classList.add("red-hp");
                    let redHP = [];
                    redHP.push(`${enemy.id}-HP`);
                    localStorage.setItem("redHP", JSON.stringify(redHP));

                    // 顯示敵人燃燒的描述
                    //document.getElementById(`${enemy.id}-action`).textContent = texts.demonAttacked;
                    localStorage.setItem(`${enemy.id}-action-text`, texts.demonAttacked);
                });
                localStorage.setItem("enemies", JSON.stringify(enemies)); // 儲存更新後的敵人資料
                localStorage.removeItem("demonAttack"); // 清除惡魔攻擊
            }

            // 讀取成員資料
            const teamMembers = JSON.parse(localStorage.getItem("teamMembers")) || [];
            let presentMembers = JSON.parse(localStorage.getItem("presentMembers")) || [];
            let actableMembers = JSON.parse(localStorage.getItem("actableMembers")) || [];
            let escapeMember = JSON.parse(localStorage.getItem("escapeMember")) || [];

            // 同步更新角色 HP、狀態
            presentMembers.forEach(member => {
                let existingMember = teamMembers.find(m => m.id === member.id);
                if (existingMember) {
                    member.HP = existingMember.HP;
                    member.status = existingMember.status;
                }
            });
            actableMembers.forEach(member => {
                let existingMember = teamMembers.find(m => m.id === member.id);
                if (existingMember) {
                    member.HP = existingMember.HP;
                    member.status = existingMember.status;
                }
            });

            // 檢查是否有角色死亡
            let deadMembers = presentMembers.filter(member => member.HP <= 0).map(member => member.name).join("、");
            if (deadMembers) {
                document.getElementById("team-action").textContent = texts.die(deadMembers); // 顯示死亡訊息（可顯示多人）
            }

            // 檢查角色是否非死即逃
            if (presentMembers.length > 0) { // 檢查上場成員是否有人（如果沒人，有可能是全員逃走）
                let allMembersDead = presentMembers.every(member => member.HP <= 0); // 檢查上場成員是否都死亡
                if (allMembersDead) {
                    if (escapeMember.length > 0) { // 檢查逃跑成員是否有人
                        // 有人死亡，剩下的人都已逃走
                        battleResult = 3;
                        localStorage.setItem("battleResult", battleResult);
                        return; // 防止繼續執行後面的邏輯
                    }
                }
            }

            // 移除死亡角色，只保留HP大於0的角色
            presentMembers = presentMembers.filter(member => member.HP > 0); 
            actableMembers = actableMembers.filter(member => member.HP > 0); 
            localStorage.setItem("presentMembers", JSON.stringify(presentMembers));
            localStorage.setItem("actableMembers", JSON.stringify(actableMembers));
            
            //console.log("剩餘成員:", presentMembers);
            //console.log("可行動的成員", actableMembers);
            generateTeam(); // 重新顯示隊伍

            // 檢查隊伍是否全滅
            if (presentMembers.length === 0) { // 檢查上場成員是否 0 人
                if (escapeMember.length === 0) { // 檢查逃跑成員是否 0 人
                    // 全員死亡
                    defeated();
                } else {
                    // 全員逃走
                    battleResult = 2;
                    localStorage.setItem("battleResult", battleResult);
                    localStorage.removeItem("inEvent"); // 清除事件
                    endBattle();
                }
                return; // 防止繼續執行後面的邏輯
            }

            // 檢查敵人是否全滅
            if (enemies.every(enemy => enemy.HP <= 0)) {
                // 戰鬥勝利
                loot();
                battleResult = 1;
                localStorage.setItem("battleResult", battleResult);
                turnSwitch(); // 如果有觸發開關，將開關打開

                // 如果有指定戰勝後的對話
                const encounter = JSON.parse(localStorage.getItem("encounter")) || [];
                if (encounter && encounter.successKey) {
                    localStorage.setItem("currentKey", encounter.successKey);
                }

                endBattle();
            }

            // 檢查是否搶劫敵人
            let robEnemy = localStorage.getItem("robEnemy") === "true"; 
            if (robEnemy) {
                // 搶劫敵人
                loot();
                battleResult = 4;
                localStorage.setItem("battleResult", battleResult);
                endBattle();
            }

            // 移除死亡的敵人
            enemies = enemies.filter(enemy => enemy.HP > 0); // 只保留HP大於0的敵人
            localStorage.setItem("enemies", JSON.stringify(enemies)); // 更新localStorage中的敵人資料
            generateEnemy(); // 重新顯示敵人
        }

        // 回合結束
        function endRound() {
            let teamMembers = JSON.parse(localStorage.getItem("teamMembers")) || [];

            // 移除標題和提示
            document.getElementById("situation").textContent = "";
            document.getElementById("battle-result").textContent = "";

            // 移除戰鬥訊息
            document.querySelectorAll(".battle-text").forEach(el => el.textContent = "");
            teamMembers.forEach(member => {
                localStorage.removeItem(`${member.id}-action-text`);
            });

            // 移除HP的紅字
            for (const el of document.querySelectorAll(".red-hp")) el.classList.remove("red-hp");
            localStorage.removeItem("redHP");

            // 判斷是否已經戰敗（因為戰勝的話，會直接在行動結束時跳轉，戰敗的話，要先讓玩家看一下發生什麼事，然後按下「回合結束」後才跳轉）
            battleResult = localStorage.getItem("battleResult");
            if (battleResult && (battleResult !== 1 || battleResult !== 2 || battleResult !== 4)) {
                localStorage.removeItem("inEvent"); // 清除事件
                endBattle();
                return;
            }
            
            // 檢查俘虜是否逃跑
                // 獲取俘虜、非俘虜成員的資料
                const prisoners = presentMembers.filter(member => member.type === "俘虜");
                const nonPrisoners = presentMembers.filter(member => member.type !== "俘虜");
   
                // 找到 dex 最高的非俘虜成員
                let maxDexMembers = [];
                let maxDex = -Infinity; // 設定初始值為負無限
                nonPrisoners.forEach(member => {
                    if (member.dex.total > maxDex) { // 如果找到更高的 dex，重置陣列，將該角色加入陣列
                        maxDex = member.dex.total; //更新最高 dex
                        maxDexMembers = [member];
                    }
                });

                // 檢查俘虜是否逃跑
                prisoners.forEach(member => {
                    // 計算逃跑成功率
                    let runChance = member.dex.total / (member.dex.total + maxDex);
                    
                    let randomValue = Math.random(); // 產生 0~1 的隨機小數
                    // 檢查成功率
                    console.log(`俘虜敏捷: ${member.dex.total}, 隊伍最高敏捷: ${maxDex}`);
                    console.log(`計算的逃跑機率: ${(runChance*100).toFixed(2)}%`);  // 顯示精確到小數點後2位

                    // 結果
                    if (randomValue <= runChance) {
                        // 俘虜逃跑
                        removepresentMembers(member.id); // 移出上場成員
                        removeCompanion(member.id); // 移出隊伍

                        // 顯示俘虜逃跑訊息（顯示在隊伍欄位，因為逃跑成功會清除角色欄位）
                        document.getElementById("team-action").textContent = texts.escapePrisoner(member.name);
                    }
                });

            // 讀取敵人資料
            let enemies = JSON.parse(localStorage.getItem("enemies")) || [];
            let enemyType = enemies.length > 0 ? enemies[0].type : 0;

            // 先將所有敵人加入可行動敵人
            let actableEnemies = [...enemies];  // 使用擴展語法確保actabeEnemies獨立於enemies

            // 每個敵人的狀態生效
            enemies.forEach(enemy => {
                if (!enemy.status) return; // 如果沒有狀態則跳過

                // 狀態效果
                enemy.status.forEach(s => {
                    if (s.name === "流血") {
                        enemy.HP -= 1; // 每回合扣血
                    } else if (s.name === "倒地") {
                        // 移出可行動敵人
                        const targetIndex = actableEnemies.findIndex(e => e.id === enemy.id);
                        if (targetIndex > -1) {
                            actableEnemies.splice(targetIndex, 1);
                        }

                        // 顯示無法行動的訊息
                        //document.getElementById(`${enemy.id}-action`).textContent = texts.unactable;
                        localStorage.setItem(`${enemy.id}-action-text`, texts.unactable);
                    }
                    s.duration --; // 減少持續回合
                });

                // 移除已結束的狀態
                enemy.status = enemy.status.filter(s => s.duration > 0);
            });

            // 儲存更新後的敵人資料
            localStorage.setItem("enemies", JSON.stringify(enemies));
            localStorage.setItem("actableEnemies", JSON.stringify(actableEnemies));

            // 檢查敵人是否投降
                // 找到 str 最高的成員
                let maxStrMembers = [];
                let maxStr = -Infinity; // 設定初始值為負無限
                presentMembers.forEach(member => {
                    if (member.str.total > maxStr) { // 如果找到更高的 str，重置陣列，將該角色加入陣列
                        maxStr = member.str.total; //更新最高 str
                        maxStrMembers = [member];
                    }
                });

                // 敵人總 HP
                let totalEnemyHP = 0;
                enemies.forEach(enemy => {
                    if (enemy.HP) {
                        for (let i = 0; i < enemies.length; i++) {
                            totalEnemyHP += enemy.HP;
                        }
                    }
                });

                // 敵人是否投降
                if (enemies.length === 1 && enemyType.includes("智慧")) {
                    if (maxStr > totalEnemyHP) {
                        // 如果只剩一個智慧敵人，且隊伍中最高力量 > 敵人 HP 時，敵人有機會投降

                        // 計算投降機率
                        let surrenderChance = maxStr / (maxStr + totalEnemyHP);
                    
                        let randomValue = Math.random(); // 產生 0~1 的隨機小數
                        // 檢查成功率
                        console.log(`隊伍最高力量: ${maxStr}, 敵人總HP: ${totalEnemyHP}`);
                        console.log(`計算的投降機率: ${(surrenderChance*100).toFixed(2)}%`);  // 顯示精確到小數點後2位

                        // 結果
                        if (randomValue <= surrenderChance) {
                            localStorage.setItem("enemySurrender", "true");
                            localStorage.setItem("npcId", "enemy1"); // 將 enemy1 儲存為交談對象
                            window.location.href = 'battleTalk.html'; // 敵人投降，跳轉到交談頁面
                            return;
                        }
                    }
                }

            // 如果敵人毫無防備，下回合恢復正常回合
            let situation = parseInt(localStorage.getItem("situation"));
            if (situation === 4) {
                //situation = 2; 
                //localStorage.setItem("situation", situation); 
                localStorage.removeItem("situation"); // 清除遇敵方式
            }

            enemyFight(); // 敵人攻擊

            // 先將所有上場成員加入可行動成員
            let actableMembers = [...presentMembers];  // 使用擴展語法確保actableMembers獨立於presentMembers

            // 角色的狀態生效
            teamMembers = JSON.parse(localStorage.getItem("teamMembers")) || []; // 再次讀取以確保是最新資料
            teamMembers.forEach(member => {
                if (!member.status) return; // 如果沒有狀態則跳過

                // 狀態效果
                member.status.forEach(s => {
                    if (s.name === "流血") {
                        member.HP -= 1; // 每回合扣血
                    } else if (s.name === "倒地") {
                        // 移出可行動成員
                        const targetIndex = actableMembers.findIndex(m => m.id === member.id);
                        if (targetIndex > -1) {
                            actableMembers.splice(targetIndex, 1);
                        }

                        // 顯示無法行動的訊息
                        //document.getElementById(`${member.id}-action`).textContent = texts.unactable;
                        localStorage.setItem(`${member.id}-action-text`, texts.unactable);
                    }
                    s.duration --; // 減少持續回合
                });

                // 移除已結束的狀態
                member.status = member.status.filter(s => s.duration > 0);
            });


            // 儲存更新後的資料
            localStorage.setItem("teamMembers", JSON.stringify(teamMembers));
            localStorage.setItem("actableMembers", JSON.stringify(actableMembers));
            endAction();

            // 檢查雷納德是否路過幫忙
                isMember = teamMembers.some(m => m.name === "雷納德");
                const inEvent = localStorage.getItem("inEvent");

                if (!isMember && teamMembers.length < 4 && teamMembers.length > 0 && !inEvent) {
                    // 如果雷納德不在隊伍中，隊伍有空位，且不是在事件中，雷納德有機率加入
                    let randomValue = Math.random();
                    if (randomValue <= 0.05) { // 5% 機率加入
                        localStorage.setItem("npcName", "雷納德");
                        showDialogue("雷納德幫忙");
                    }
                }

            // 重新顯示隊伍欄位及按鈕
            generateTeam(); 

            window.scrollTo({ top: 0, behavior: "smooth" }); // 跳到畫面上方
        }

        // 獲得金錢和戰利品
        function loot() {
            // 讀取所有敵人的資料
            let enemies = JSON.parse(localStorage.getItem("enemies")) || [];

            // 讀取初始敵人數量
            let enemyCount = parseInt(localStorage.getItem("enemyCount"));
                
            // 讀取玩家的金錢與物品
            let playerMoney = parseInt(localStorage.getItem("playerMoney")) || 0;
            let playerItems = JSON.parse(localStorage.getItem("playerItems")) || [];

            let totalMoney = 0;
            let totalLoot = [];

            // 計算金錢和戰利品
            enemies.forEach(enemy => {
                // 金錢
                if (enemy.money) {
                    totalMoney += enemy.money * enemyCount;
                    playerMoney += enemy.money * enemyCount;
                }
                // 戰利品（一般戰利品 + 武器 + 護甲）
                for (let i = 0; i < enemyCount; i++) {
                    if (enemy.loot) totalLoot.push(enemy.loot);
                    if (enemy.weaponId) totalLoot.push(enemy.weaponId);
                    if (enemy.armorId) totalLoot.push(enemy.armorId);
                }
            });

            // 更新玩家金錢與物品
            playerItems = playerItems.concat(totalLoot);
            localStorage.setItem("playerItems", JSON.stringify(playerItems));
            localStorage.setItem("playerMoney", playerMoney);

            // 統計戰利品的數量
            let lootCount = totalLoot.reduce((count, loot) => {
                count[loot] = (count[loot] || 0) + 1;
                return count;
            }, {});

            // 顯示獲得的金錢和戰利品
            let lootResult;

            // 獲得的金錢
            let moneyText = totalMoney > 0 ? `獲得 🪙 $${totalMoney}<br>` : "";

            // 獲得的戰利品
            let lootText = Object.keys(lootCount).map(loot => {
                let item = itemDatabase.find(i => i.id === loot);
                return item ? `獲得 ${item.name} × ${lootCount[loot]}` : "";
            }).filter(text => text !== "").join("<br>");

            lootResult = moneyText + lootText;
            localStorage.setItem("lootResult", lootResult);
        }

        // 戰敗後的處理
        function defeated() {
            // 讀取第一個敵人的類型
            let enemies = JSON.parse(localStorage.getItem("enemies")) || [];
            let enemyType = enemies.length > 0 ? enemies[0].type : 0;

            // 讀取目前已逃跑的成員
            let escapeMember = JSON.parse(localStorage.getItem("escapeMember")) || [];
            let playerEscaped = escapeMember.some(member => member.id === "player");

            const encounter = JSON.parse(localStorage.getItem("encounter"));

            // 決定戰敗的情況
            if (enemyType.includes("類人") && !playerEscaped && !encounter) {
                // 如果是類人敵人、主角沒有逃走，也不是指定戰鬥，就隨機決定情況
                let randomValue = Math.random();

                if (randomValue < 1) { // 100% 被搶劫
                    battleResult = 6;
                } else { // 0% 被抓去當奴隸（尚未實裝）
                    battleResult = 7; 
                }                
                localStorage.setItem("battleResult", battleResult);

            } else { 
                // 否則單純被擊倒
                battleResult = 5;
                localStorage.setItem("battleResult", battleResult);
            }
            
            // 處理戰敗的情況
            if (battleResult === 6) { // 被搶劫的情況
                // 讀取主角金錢
                let playerMoney = parseInt(localStorage.getItem("playerMoney")) || 0;

                // 如果有錢，執行搶劫
                if (playerMoney > 0) {
                    // 隨機決定被搶走的金額（至少 1，最多一半）
                    let robbedMoney = Math.max(1, Math.floor(Math.random() * playerMoney * 0.5));
                    robbedMoney = Math.min(robbedMoney, playerMoney); // 確保不會超過擁有的金額

                    // 扣除金錢並儲存
                    playerMoney -= robbedMoney;
                    localStorage.setItem("playerMoney", playerMoney);
                    localStorage.setItem("robbedMoney", robbedMoney);

                } else {
                    // 沒有錢，改為普通擊倒
                    battleResult = 5;
                    localStorage.setItem("battleResult", battleResult);
                }

            } else if (battleResult === 7) { // 成為奴隸的情況（尚未實裝）

            }

            // 檢查有沒有包裹，隨機損壞一件
            let playerItems = JSON.parse(localStorage.getItem("playerItems")) || [];
            let packages = playerItems.filter(item => item === "specialItem01" || item === "specialItem03");

            if (packages.length > 0) {
                // 隨機選擇一件包裹
                let randomPackage = packages[Math.floor(Math.random() * packages.length)];

                // 根據這個包裹的id替換為損壞包裹
                playerItems = playerItems.map(item => {
                    if (item === randomPackage) {
                        return randomPackage === "specialItem01" ? "specialItem02" : "specialItem04"; // 替換為損壞版本
                    }
                    return item; // 保留其他包裹不變
                });

                // 更新 localStorage
                localStorage.setItem("playerItems", JSON.stringify(playerItems));
            }

            // 如果有指定戰敗後的對話
            if (encounter && encounter.failKey) {
                localStorage.setItem("currentKey", encounter.failKey);
            } else {
                localStorage.removeItem("inEvent"); // 清除事件
            }
                
            localStorage.removeItem("helpVictim"); // 清除「幫助平民」開關

            // 隨機決定重生的情況
            let respawn;
            let randomValue = Math.random();
            if (randomValue < 0.5) { // 50% 原地重生
                respawn = 1; 
            } else { // 50% 被送回城鎮
                respawn = 2; 
            }

            // 如果在事件中，只會原地重生
            const inEvent = localStorage.getItem("inEvent");
            if (inEvent) {
                respawn = 1; 
            }
            
            // 如果指定敵人是守衛，就會被逮捕
            if (encounter && encounter.enemyName === "守衛") {
                respawn = 3; // 在監獄重生
            }

            // 儲存重生的情況
            localStorage.setItem("respawn", respawn);
        }

        // 戰鬥結束
        function endBattle() {  
            window.location.href = 'battleResult.html'; // 跳轉到戰鬥結果頁面
        }

        // 幫手加入
        function helperJoin() {
            // 加入隊伍
            const npcName = localStorage.getItem("npcName");
            let companion = mercenaries.find(comp => comp.name === npcName);
            addCompanion(companion);

            // 找到隊中的id
            const teamMembers = JSON.parse(localStorage.getItem("teamMembers")) || [];
            let member = teamMembers.find(m => m.name === npcName);

            // 加入上場成員、可行動成員
            let presentMembers = JSON.parse(localStorage.getItem("presentMembers")) || [];
            let actableMembers = JSON.parse(localStorage.getItem("actableMembers")) || [];
            presentMembers.push(member);
            actableMembers.push(member);
            localStorage.setItem("presentMembers", JSON.stringify(presentMembers));
            localStorage.setItem("actableMembers", JSON.stringify(actableMembers));

            generateTeam();
        }
    </script>

</body>
</html>
